{
    "contents" : "//c++ naming conventions\n/*\n they all must return void\n parameters by reference\n include the R.h\n */\n#include \"Cayley.h\"\n#include \"Kendall.h\"\n#include \"Hamming.h\"\n#include \"Ulam_disk.h\"\n#include \"Ulam.h\"\n#include \"Newton_raphson.h\"\n#include \"Exponential_model.h\"\n#include \"Lap.h\"\n\n#include <R.h>\n#include <Rmath.h>\n#include <Rinternals.h>\n#include <Rdefines.h>\n\n/* dist:id\n 0: cayley\n 1: kendall\n 2: hamming\n 3: ulam\n 4: ULAM_DISK_DISTANCE\n */\nextern \"C\" {\n    \n    void count_permus_with_at_least_k_unfixed_points ( int*n, int *k, double * res){\n        GetRNGstate();\n        Generic gen;\n        *res = (double)gen.count_permus_with_at_least_k_unfixed_points(*n, *k);\n        PutRNGstate();\n    }\n    \n    void random_permutation(int *n, int *sigma){\n      GetRNGstate();\n        Generic gen;\n        gen.generate_random_permutation(*n, FIRST_ITEM, sigma);\n        PutRNGstate();\n    }\n    \n    void compute_distance (int*dist_id, int*n,int*s1, int*s2, int*d) {\n      GetRNGstate();\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        *d=exp_mod->distance(s1,s2);\n        delete exp_mod;\n        PutRNGstate();\n    }\n    \n    void count_permus_at_dist (int*dist_id, int*n, int*d, double*res) {\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        if (*d < 0 || *d > exp_mod->maximum_distance()) *res = 0;\n        else *res= (double) exp_mod->num_permus_at_distance(*d);\n        delete exp_mod;\n        PutRNGstate();\n    }\n    \n    void probability(int*dist_id, int*n, int*sigma, int*sigma_0, double*theta, double*prob){\n      GetRNGstate();\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        *prob = exp_mod->probability(sigma, sigma_0, theta);\n        delete exp_mod;\n        PutRNGstate();\n    }\n    \n    void get_altern_repre_for_permu(int*dist_id, int*n, int*sigma, int*vec){\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        exp_mod->perm2dist_decomp_vector(sigma, vec);\n        delete exp_mod;\n    }\n    \n    void get_permu_given_altern_repre(int*dist_id, int*n, int*vec, int*sigma){\n      GetRNGstate();\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        exp_mod->dist_decomp_vector2perm(vec, sigma);\n        delete exp_mod;\n        PutRNGstate();\n    }\n    \n    void expectation(int*dist_id, int* model, int *n, double * theta, double* h_avg){\n      GetRNGstate();\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(*dist_id, *n);\n        if ( *model == MALLOWS_MODEL )\n          h_avg[0] = exp_mod->expectation(theta[ 0 ]);\n        else exp_mod->expectation(theta, h_avg);\n        delete exp_mod;\n        PutRNGstate();\n    }\n    \n    void save_counts_to_files ( int*n){\n      GetRNGstate();\n        Ulam_disk * ul = new Ulam_disk(*n);\n        ul->save_counts_to_file_bin();\n        delete ul;\n        PutRNGstate();\n    }\n    \n    void marginals ( int*n, int *dist_id, int *h, double * theta, double *res){\n      GetRNGstate();\n        Hamming *ham = new Hamming(*n);\n        *res = ham->compute_marginal(h, theta);\n        delete ham;\n        PutRNGstate();\n    }\n    \n    \n    /***************       SAMPLING (GENERATING)      *******************/\n    \n    SEXP get_random_sample_at_dist_d(SEXP dist_id_var, SEXP n_var, SEXP m_var, SEXP d_var){\n      GetRNGstate();\n        \n        SEXP Rval;\n        int n = INTEGER_VALUE(n_var);\n        int m  = INTEGER_VALUE(m_var);\n        int d = INTEGER_VALUE(d_var);\n        int dist_id = INTEGER_VALUE(dist_id_var);\n        \n        int**sample=new int*[m];\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        exp_mod->random_sample_at_dist(d, m, sample);\n        \n        PROTECT(Rval = allocMatrix(REALSXP, m, n));\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                REAL(Rval)[i + m * j] = sample[i][j];\n        UNPROTECT(1);\n        for (int i = 0 ; i < m ;  i ++ ) delete [] sample[ i ];\n        delete [] sample;\n        delete exp_mod;\n        PutRNGstate();\n        return Rval;\n    }\n    \n    SEXP distances_sampling(SEXP dist_id_var, SEXP n_var, SEXP m_var, SEXP theta_var){\n      GetRNGstate();\n        int     m  =    INTEGER_VALUE(m_var);\n        int     n  =    INTEGER_VALUE(n_var);\n        int dist_id  =  INTEGER_VALUE(dist_id_var);\n        double theta =  NUMERIC_VALUE(theta_var);\n        int  **sample=  new int*[m];\n        SEXP Rval;\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        exp_mod->distances_sampling(m,theta,sample);\n\n        PROTECT(Rval = allocMatrix(REALSXP, m, n));\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                REAL(Rval)[i + m * j] = sample[i][j];\n        UNPROTECT(1);\n        for (int i = 0 ; i < m ;  i ++ ) delete [] sample[ i ];\n        delete [] sample;\n        delete exp_mod;\n        PutRNGstate();\n        return Rval;\n    }\n    \n    \n    \n    //sam <- .Call(\"sampling_multi_gibbs_cayley\",dist_id,  permu.length, num.permus, theta, 0, algorithm_id)\n    SEXP sampling_multi_gibbs_cayley(SEXP dist_id_var,SEXP n_var, SEXP m_var,\n                                     SEXP theta_var, SEXP model_var,SEXP method_var){\n         GetRNGstate();\n        //method_var == 1 multistage\n        //method_var == 2 gibbs\n        int m  = INTEGER_VALUE(m_var);\n        int n  = INTEGER_VALUE(n_var);\n        int model    = INTEGER_VALUE(model_var);//GMM MM\n        int method ;\n        method = INTEGER_VALUE(method_var);//gibbs...\n        int dist_id  = INTEGER_VALUE(dist_id_var);\n        PROTECT(theta_var = AS_NUMERIC(theta_var));\n        double*theta=NUMERIC_POINTER(theta_var);\n        UNPROTECT(1);\n        //return(R_NilValue);\n        \n        int**sample=new int*[m];\n        SEXP Rval;\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        if(method == 1)\n            exp_mod->multistage_sampling(m,theta, sample);\n        else\n            exp_mod->gibbs_sampling(m, theta, model,sample);\n            \n        PROTECT(Rval = allocMatrix(REALSXP, m, n));\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                REAL(Rval)[i + m * j] = sample[i][j];\n        UNPROTECT(1);\n        for (int i = 0 ; i < m ;  i ++ ) delete [] sample[ i ];\n        delete [] sample;\n        delete exp_mod;\n        PutRNGstate();\n        return Rval;\n    }\n    \n    /***************       LEARNING (FITTING)     *******************/\n    \n    SEXP consensus (SEXP dist_id_var, SEXP samples, SEXP mm_var, SEXP estim_var, SEXP sigma_0_ini_var){\n        //mm_var==0 mm\n        //mm_var==1 gmm\n        //estim_var == 0 exact\n        \n        GetRNGstate();\n        \n        SEXP Rdim = getAttrib(samples, R_DimSymbol);\n        \n        //PROTECT(sigma_0_ini_var = AS_INTEGER(sigma_0_ini_var));\n        //int*sigma_0_ini=INTEGER_POINTER(sigma_0_ini_var);\n        //UNPROTECT(1);\n        PROTECT(samples = AS_INTEGER(samples));\n        int m = INTEGER(Rdim)[0];\n        int n = INTEGER(Rdim)[1];\n        int model = INTEGER_VALUE(mm_var);\n        int estim = INTEGER_VALUE(estim_var); // 0 exact;\n        int dist_id = INTEGER_VALUE(dist_id_var);\n        int**c_samples=new int*[m];\n        int*sigma_0=new int[n];\n        \n        for(int i=0;i<m;i++){\n            c_samples[i]=new int[n];\n            for(int j=0;j<n;j++){\n                c_samples[i][j]=INTEGER(samples)[i + m * j];\n            }\n        }\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        if (estim == 0)\n            exp_mod->estimate_consensus_exact( model, m,c_samples, NULL, sigma_0);\n        else\n            exp_mod->estimate_consensus_approx(model, m,c_samples, sigma_0);\n\n        SEXP myint;\n        int *p_myint;\n        int len = n;\n        // Allocating storage space:\n        PROTECT(myint = NEW_INTEGER(len));\n        p_myint = INTEGER_POINTER(myint);\n        for(int i=0;i<n;i++) p_myint[i] = sigma_0[i];\n        UNPROTECT(2);\n        delete exp_mod;\n        for(int i=0;i<m;i++) delete [] c_samples[ i ];\n        delete [] c_samples;\n        delete [] sigma_0;\n        PutRNGstate();\n        return myint;\n    }\n    \n    SEXP estimate_theta(SEXP dist_id_var, SEXP n_var, SEXP m_var, SEXP sigma_0_var, SEXP samples_var, SEXP model_var){\n        //model (model_var)  MM=0 ;;;; 1 =GMM\n        \n        GetRNGstate();\n        SEXP Rval;\n        int i;\n        PROTECT(Rval = allocVector(INTSXP, 1));\n        for (i = 0; i < 1; i++)\n            INTEGER(Rval)[i ] = i;\n        UNPROTECT(1);\n        int n = INTEGER_VALUE(n_var);\n        int m = INTEGER_VALUE(m_var);\n        int dist_id = INTEGER_VALUE(dist_id_var);\n        int model = INTEGER_VALUE(model_var);\n        int**samples=new int*[m];\n        PROTECT(samples_var = AS_INTEGER(samples_var));\n        for(int i=0;i<m;i++){\n            samples[i]=new int[n];\n            for(int j=0;j<n;j++)\n                samples[i][j]=INTEGER(samples_var)[i + m * j];\n        }\n        double*theta= new double[n];\n        PROTECT(sigma_0_var = AS_INTEGER(sigma_0_var));\n        int*sigma_0 = INTEGER_POINTER(sigma_0_var);\n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        exp_mod->estimate_theta(m, sigma_0, samples, model, theta);\n\n        UNPROTECT(2);\n        PROTECT(Rval = allocVector(REALSXP, n));\n        for (int i = 0; i < n ; i++) REAL(Rval)[i] = theta[i];\n        UNPROTECT(1);\n        delete [] theta;\n        for (int i = 0 ; i < m ;  i ++ ) delete [] samples[ i ];\n        delete [] samples;\n        delete exp_mod;\n        PutRNGstate();\n        return Rval;\n    }\n    //Call(\"get_log_likelihood\",dist_id,    permu.length, num.permus, sigma_0, theta, samples, model)\n    \n    SEXP get_log_likelihood(SEXP dist_id_var, SEXP n_var, SEXP m_var, SEXP sigma_0_var, SEXP theta_var,\n                            SEXP samples_var, SEXP model_var){\n        \n        GetRNGstate();\n        //model (model_var)  MM=0 ;;;; 1 =GMM\n        SEXP Rval;\n        int i;\n        double likeli = -1.0;\n        PROTECT(Rval = allocVector(INTSXP, 1));\n        for (i = 0; i < 1; i++)\n            INTEGER(Rval)[i ] = i;\n        UNPROTECT(1);\n        int n         = INTEGER_VALUE( n_var );\n        int m         = INTEGER_VALUE( m_var );\n        int dist_id   = INTEGER_VALUE( dist_id_var );\n        int model     = INTEGER_VALUE( model_var );\n        \n        int**samples  = new int*[ m ];\n        PROTECT(samples_var = AS_INTEGER( samples_var ));\n        for(int i=0;i<m;i++){\n            samples[i]=new int[n];\n            for(int j=0;j<n;j++)\n                samples[ i ][ j ] = INTEGER(samples_var)[i + m * j];\n        }\n        int last_theta = n;\n        if( dist_id == CAYLEY_DISTANCE || dist_id == KENDALL_DISTANCE ) last_theta = n-1;\n        \n        /*double * theta = new double[ n ];\n        PROTECT(theta_var = AS_NUMERIC(samples_var));\n        for(int i = 0 ; i < last_theta ; i ++)\n            theta[ i ] = REAL(theta_var)[ i ];\n        */\n        int * sigma_0 = new int[ n ];\n        PROTECT(sigma_0_var = AS_INTEGER(sigma_0_var));\n        for(int i = 0 ; i < n ; i ++)\n            sigma_0[ i ] = INTEGER(sigma_0_var)[ i ];\n        \n        Generic gen;\n        Exponential_model * exp_mod = gen.new_instance(dist_id, n);\n        likeli = exp_mod->get_likelihood(m, samples, model, sigma_0);\n\n        UNPROTECT(2);\n        //cout<<\"liekli .. \"<<likeli<<endl;\n        PROTECT(Rval = allocVector(REALSXP, 1));//vector len 1\n        REAL(Rval)[0] = likeli;\n        //for (int i = 0; i < n - 1; i++) REAL(Rval)[i] = theta[i];\n        UNPROTECT(1);\n        delete exp_mod;\n        for (int i = 0 ; i < m ;  i ++ ) delete [] samples[ i ];\n        delete [] samples;\n        delete [] sigma_0;\n        PutRNGstate();\n        return Rval;\n    }\n    \n} // extern \"C\"\n",
    "created" : 1437635761687.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2155939058",
    "id" : "3E26D988",
    "lastKnownWriteTime" : 1441817281,
    "path" : "~/Dropbox/permus/prj/R/PerMallows/src/Wrapper.cpp",
    "project_path" : "src/Wrapper.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}