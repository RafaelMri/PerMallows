{
    "contents" : "//\n//  Cayley.cpp\n//  perms_mallows\n//\n//  Created by Ekhine Irurozki on 20/06/13.\n//  Copyright (c) 2013 Ekhine Irurozki. All rights reserved.\n//\n#include <R.h>\n#include \"Cayley.h\"\n#include \"Generic.h\"\n#include \"Newton_raphson.h\"\n#include \"Ulam.h\"\n#include <cmath>\n#include <cfloat>\n\ndouble  Cayley::expectation(double theta) {\n        double sum=0, ex, denom;\n        for(int j = 1 ; j < n_ ; j++){\n            ex = exp(theta);\n            denom = j+ex;\n            sum += (double)j/denom;\n            //sum += (double) j /(double)(exp(theta)+(double)j);\n        }\n        return (double)(sum );\n    }\n    \nvoid    Cayley::expectation(double *theta, double *expect) {\n  for (int i = 0 ; i < n_ - 1; i ++){\n    int j = i + 1;\n    expect[ i ] = (n_-j) / ((n_-j)+exp(theta[i]));\n  }\n  expect[ n_ - 1 ] = 0;\n}\n\ndouble Cayley::probability(int *s, int *s_0, double *theta){\n    int     *x = new int[ n_ ],*comp = new int[ n_ ], *inv = new int[ n_ ];\n    double  *psi    = new double[ n_ ];\n    double  proba   =1;\n    for (int i = 0 ; i < n_; i ++ ) inv[s_0[ i ]-1] =i+1;\n    for (int i = 0 ; i < n_; i ++ ) comp[ i ] =s[inv[ i ]-1];\n    perm2dist_decomp_vector(comp, x);\n    calculate_psi(theta, psi);\n    for(int i = 0 ; i < n_ - 1 ; i ++ ) proba *= exp(-theta[ i ]*x[ i ])/psi[ i ];\n    delete []psi;\n    delete []comp;\n    delete []inv;\n    delete []x;\n    return proba;\n}\n\ndouble Cayley::get_theta_log_likelihood(int m, int *x_acumul, int *x_acumul_variation, double *theta_estim){\n    double likeli= 0;\n    double *psi;\n    psi = new  double[ n_ ];\n    theta_estim[n_-1] = 0;\n    for(int i = 0;i < n_ - 1; i ++ ){\n        int x_i = x_acumul[ i ];\n        if(x_acumul_variation != NULL)x_i += x_acumul_variation[ i ];\n        int j = i+1;\n        if(x_i == 0)  x_i = 1;\n        if(x_i == m)  x_i = m-1;\n        double xav = (double) x_i/m;\n        if(xav != 0){\n            theta_estim[ i ] =log(n_-j)-log(xav / (1-xav));\n            //if(theta_estim[ i ] < 0)theta_estim[ i ] = 0;\n            psi[ i ] =1+(n_-j)*exp(-theta_estim[ i ]);\n            likeli += x_i * theta_estim[ i ] + m * log(psi[ i ]);\n            if ( likeli != likeli)\n                likeli= 0;\n        }else theta_estim[ i ] = 0;\n    }\n    delete [] psi;\n    return (-1 * likeli);\n}\nvoid Cayley::get_x_lower_bound_freq(int m, int ** samples_inv_freq, int ini_pos, int *min_bound_x){\n    int *freq = new int[ n_ ]; for (int i = 0 ; i < n_; i ++ )freq[ i ] = 0;\n    int maxFreq= 0, minFreq = m;\n    for(int j=ini_pos;j<n_-1;j++){\n        for(int s= 0;s<n_;s++){\n            freq[ s ] += samples_inv_freq[ j ][ s ];\n            if(freq[ s ]> maxFreq)\n                maxFreq=freq[ s ];\n            if(freq[ s ] < minFreq)\n               minFreq=freq[ s ];\n        }\n        min_bound_x[ j ] = m - maxFreq;\n        max_bound_x = m - minFreq;\n        \n        axv = double(min_bound_x[ j ] )/ m\n        theta_estim =log(n_-j)-log(xav / (1-xav));\n        psi =1+(n_-j)*exp(-theta_estim);\n        likeli += x_i * theta_estim + m * log(psi);\n        likelimi = likeli;\n        \n        \n        \n        \n        \n        if(min_bound_x[ j ]<0)min_bound_x[ j ] = 0;\n    }\n    delete []freq;\n}\nvoid Cayley::get_x_lower_bound(int m, int ** sample, int ini_pos, int *x_min_bound){\n    int *freq = new int[ n_ ]; for (int i = 0 ; i < n_; i ++ )freq[ i ] = 0;\n    int max_freq= 0;\n    for(int j=ini_pos;j<n_-1;j++){\n        for(int s= 0;s<m;s++){\n            freq[sample[ s ][ j ]-1]++;\n            if(freq[sample[ s ][ j ]-1]> max_freq)\n                max_freq=freq[sample[ s ][ j ]-1];\n        }\n        x_min_bound[ j ] =m-max_freq;\n        if(x_min_bound[ j ]<0)x_min_bound[ j ] = 0;\n    }\n    //  for (int i = 0 ; i < n; i ++ ) cout<<xMinBound[ i ]<<\" \";cout<<\" xbound, pos: \"<<iniPos<<endl;\n    delete []freq;\n}\n\n/* returns 2 vectors. item cycle_items[ i ] belongs to cycle cycle_indices[ i ]*/\nint Cayley::get_cycles(int *sigma, int *cycle_items, int *cycle_indices){\n    bool*visited = new bool[ n_ ];\n    for (int i = 0 ; i < n_; i ++ )visited[ i ] =false;\n    int item_index, cont=0, cycle_index= 0;\n    while( cont < n_ ) {\n        item_index = 0;\n        while(visited[item_index])item_index++;\n        while (!visited[item_index]) {\n            visited[item_index] = true;\n            cycle_items[cont] =item_index+1;\n            cycle_indices[cont] =cycle_index;\n            item_index=sigma[item_index]-1;\n            cont++;\n        }\n        cycle_index++;\n    }\n    delete [] visited;\n    return cycle_index;\n}\n\nvoid Cayley::random_sample_at_dist(int d, int m, int **samples){\n    //samples must be initialized before as samples = new int*[ m ];\n    for (int i = 0 ; i < m; i ++ ){\n        samples[ i ] = new int[ n_ ];\n        generate_permu_with_k_cycles(n_, n_ - d , samples[ i ]);\n    }\n}\ndouble Cayley::calculate_psi(double *theta, double *psi_vector){\n    double psi = 1;\n    for (int i = 0 ; i <  n_ - 1; i ++ ){\n        int j = i + 1;\n        psi_vector[ i ] = 1 + ( n_ - j ) *(double) exp(-theta[ i ]);\n        psi *= psi_vector[ i ];\n    }\n    return psi;\n}\n\n\nvoid Cayley::generate_permu_with_k_cycles(int n, int k, int * sigma){\n    // n: 1..n_\n    bool * long_cycle = new bool [ n_ ];\n    int ran2;\n    long double  ran1 ;\n    \n    while ( k > 1 ){\n        ran1 =(long double) unif_rand();\n        //ran1 = ((long double)rand() / ((double)RAND_MAX + 1 ) );\n        if(ran1 < (long double)(stirling_matrix_[ n - 1 ][ k - 1 ] / stirling_matrix_[ n ][ k ])){\n            long_cycle[ n - 1 ] = false;\n            k --;\n        }else{\n            long_cycle[ n - 1 ] = true;\n        }\n        n --;\n    }\n    Generic gen; //use sigma_inv_ as auxiliary array\n    //the n first items form a cycle\n    gen.generate_random_permutation(n, 0, sigma_inv_);\n    for (int i = 0 ; i < n-1; i ++ ) sigma[sigma_inv_[ i ]] = sigma_inv_[i+1]+1;\n    sigma[sigma_inv_[n-1]] =sigma_inv_[0]+1;\n    \n    for (int i = n ; i < n_ ; i++){\n        if ( long_cycle[ i ] ){\n            //ran2 = rand() % ( i ) ;//0..n-2\n            ran2 = (int) (unif_rand() * i );//[ 0,i)\n            sigma[ i ] = sigma[ ran2 ];\n            sigma[ ran2 ] = i + 1;\n        }else{\n            sigma[ i ] = i + 1;\n        }\n    }\n    delete [] long_cycle;\n}\n\nvoid Cayley::dist_decomp_vector2perm(int* vec, int* sigma) {\n    x_vector_to_permutation_forward(vec , sigma);\n    //x_vector_to_permutation_backwards(vec , sigma);\n}\nvoid Cayley::x_vector_to_permutation_forward(int *x, int *sigma){\n    int random, aux;\n    for ( int i = 0 ; i < n_ ; i++) sigma[ i ] = i + 1;\n    for ( int i = 0 ; i < n_ - 1 ; i++)\n        if ( x [ i ] == 1 ){\n            //random = (i + 1) + ( rand() % (n_ - i - 2 + 1) ); // random \\in (i + 1)+[0..n-i-2] = [i+1..n-1]\n            random = (i + 1) +  (int)( unif_rand() * (n_ - i - 2 + 1) );\n            aux = sigma[  random ];\n            sigma[ random ] = sigma[ i ];\n            sigma[ i ] = aux;\n        }        \n}\n\n\nvoid Cayley::x_vector_to_permutation_backwards(int *x, int *sigma){\n    int     dist =  0;\n    int     tables_num = 0 ;\n    for (int i = 0 ; i < n_ ; i ++) dist += x[ i ];\n    int     * tables_len = new int [ n_ - dist ];\n    int     ** tables    = new int*[ n_ - dist ];\n    for ( int i = 0 ; i < n_ - dist ; i++) {\n        tables_len[ i ] = 1;\n        tables[ i ] = new int[ dist + 1 ];\n        for (int j = 0 ; j < dist ; j ++) tables[ i ][ j ] = 0 ;\n    }\n    \n    x[ n_ - 1 ] = 0 ; //\n    for ( int i = n_ - 1 ; i >= 0 ; i--){\n        if ( x[ i ] == 0 ){ //sit the item at a new table\n            tables[ tables_num ][ 0 ] = i;\n            tables_num ++;\n        }else{//unformly at random choose an item i among the ones that are sitting\n            //and sit the new item at the right of i\n            int table_num_insert = 0, table_pos_insert = 0;\n            //table_pos_insert = (int) rand() % ( n_ - i - 1 );\n            table_pos_insert = (int) ( unif_rand() * ( n_ - i - 1 ));\n            while ( table_pos_insert >= tables_len[ table_num_insert ] ){\n                table_pos_insert -= tables_len[ table_num_insert ] ;\n                table_num_insert ++;\n            }\n            tables[ table_num_insert ][ tables_len[table_num_insert] ] = i;\n            tables_len [table_num_insert ] ++;\n        }\n    }\n    Generic gen;\n    \n    for (int i = 0 ; i < tables_num ; i++ ){\n        gen.random_shuffle(tables_len[ i ], tables[ i ]);\n        sigma[ tables[ i ][ tables_len[ i ] - 1 ]  ] = tables[ i ][ 0 ]  + FIRST_ITEM;\n        for (int j = 0 ; j < tables_len[ i ] - 1 ; j++)\n            sigma[ tables[ i ][ j ] ] = tables[ i ][ j + 1 ] + FIRST_ITEM;\n  \n        delete [] tables[ i ];\n    }\n    delete [] tables;\n    delete [] tables_len;\n    \n}\n\n\n\nlong double Cayley::num_permus_at_distance(int d){\n    return stirling_matrix_[n_ ][ n_ - d];\n}\nlong double Cayley::count_permus_with_cycles(int d){\n    return stirling_matrix_[n_ ][ n_ - d];\n}\n\n\nint Cayley::distance(int * s, int * t){\n    int *comp = new int[ n_ ], *sigma_inv = new int[ n_ ];\n    Generic gen;\n    for(int j = 0 ; j < n_ ; j++) sigma_inv[t[ j ]-1] =j + 1;\n    for(int i = 0 ; i < n_ ; i++) comp[ i ] = s [ sigma_inv [ i ] - 1 ];\n    int dist = perm2dist_decomp_vector(comp, NULL);\n    delete [] sigma_inv;\n    delete [] comp;\n    return dist;\n}\n\nint Cayley::perm2dist_decomp_vector(int*sigma, int*vec ){\n    //x is a vector of length n\n    //also updates the x vector if it isnot null\n    if(vec!=NULL)for (int i = 0 ; i < n_; i ++ )vec[ i ] =1;\n    //for (int i = 0 ; i < n; i ++ )cout<<sigma[ i ]<<\" \";cout<<endl;\n    int num_cycles=0, num_visited=0, item= 0;\n    bool*visited = new bool[ n_ ];\n    for (int i = 0 ; i < n_; i ++ )visited[ i ] =false;\n    while(num_visited < n_ ){\n        item = num_cycles;\n        while ( visited[ item ]) item++;\n        num_cycles++;\n        int max_item_in_cycle= 0;\n        do{\n            if ( item > max_item_in_cycle ) max_item_in_cycle = item;\n            visited[ item ] =true;\n            num_visited++;\n            item = sigma[ item ]-1;\n        }while ( !visited[ item ] );\n        if(vec != NULL )vec[ max_item_in_cycle ] = 0;\n    }\n    delete [] visited;\n    return (n_ - num_cycles );\n}\n\n\nvoid Cayley::distances_sampling(int m, double theta, int **samples) {\n    int     target_dist = 0;\n    double  rand_val;\n    long double *acumul = new long double[ n_ ];//+1\n    acumul[0] =exp(-theta  * 0) * stirling_matrix_[ n_ ][ n_ ];//stirling1(n_,n_);\n    for(int dista = 1 ; dista < n_ ; dista++)\n        acumul[dista] =acumul[ dista - 1 ] +  exp(-theta  * dista) * stirling_matrix_[ n_ ][ n_ - dista ];//stirling1(n_,n_-dista);\n    for (int i = 0 ; i < m; i ++ ){\n        target_dist = 0;\n        //rand_val = (double) acumul[ n_ - 1 ] * (double) rand() / RAND_MAX;\n        rand_val = (double) (acumul[ n_ - 1 ] * unif_rand());\n        while(acumul[target_dist] <= rand_val) target_dist++;\n        //int *sigma=generate_permu_with_k_cycles(n_,(n_-target_dist));\n        samples[ i ] = new int [ n_ ];\n        generate_permu_with_k_cycles(n_,(n_-target_dist), samples[ i ]);\n    }\n    delete []acumul;\n}\n\n\n\nvoid Cayley::multistage_sampling(int m, double *theta, int **samples){\n    double *psi = new double[n_-1];\n    int *x = new int[ n_ ];\n    Generic gen;\n    \n    calculate_psi(theta, psi);\n    for(int samp = 0 ; samp < m ; samp++){\n        for(int i= 0;i < n_ - 1; i ++ ){\n            double probaX_j = (double) 1/psi[ i ];//(double) exp(-theta[ i ])/psi[ i ]; //\n            //if(((double)rand() / RAND_MAX) < probaX_j) x[ i ] = 0;\n            if(( unif_rand() ) < probaX_j) x[ i ] = 0;\n            else x[ i ] =1;\n        }\n        x[n_-1] = 0;\n        int *sigma = new int[ n_ ];\n        dist_decomp_vector2perm(x, sigma);\n        samples[samp] = sigma;\n    }\n    delete [] x;\n    delete [] psi;\n}\n\n\nbool Cayley::same_cycle(int i, int j, int *sigma){\n    int index = sigma[ i ] - 1;\n    while(index != i && index != j)index = sigma[index]-1;\n    if(index == j) return true;\n    return false;\n}\n\nvoid Cayley::get_max_item_in_future_cycles(int *sigma, int i, int j, int *max_i, int *max_j){\n    \n    int pos=sigma[ i ]-1;\n    *max_j = pos;\n\n    while(pos != j ){\n        pos  = sigma[pos]-1;\n        if(pos > *max_j ) *max_j = pos;\n    }\n    pos=sigma[ j ]-1;\n    *max_i = pos;\n    while(pos != i){\n        pos  = sigma[pos]-1;\n        if(pos > *max_i ) *max_i = pos;\n    }\n}\n\nvoid Cayley::get_max_item_in_current_cycle(int *sigma, int i, int *max_i ){\n    int pos=sigma[ i ]-1;\n    *max_i = pos;\n    while(pos != i ){\n        pos  = sigma[pos]-1;\n        if(pos > *max_i ) *max_i = pos;\n    }\n}\n\n\nvoid Cayley::gibbs_sampling(int m, double *theta, int model, int **samples) {\n    int *sigma  = new int[ n_ ];\n    Generic     gen;\n    int burning_period_samples = n_*log(n_);\n    gen.generate_random_permutation(n_, 1, sigma);\n    \n    for(int sample= 0;sample<m+burning_period_samples;sample++){\n        int i,j, max_i=-1, max_j=-1, min;\n        do{\n            i = (int) (unif_rand() * n_); //rand() % n_;\n            j = (int) (unif_rand() * n_); //rand() % n_;\n        }while(i == j);\n        bool make_swap = false;\n        if(  same_cycle(i, j, sigma) )  make_swap=true;\n        else{\n            //double rand_double = (double)rand()/RAND_MAX;\n            double rand_double = unif_rand();\n            if(model == MALLOWS_MODEL){\n                if(rand_double < exp(-theta[0])) make_swap = true;\n            }else{\n                get_max_item_in_current_cycle(sigma, i, &max_i);\n                get_max_item_in_current_cycle(sigma, j, &max_j);\n                min = (max_i < max_j) ? max_i : max_j;\n                if(rand_double < exp(-theta[min])) make_swap = true;\n            }\n        }\n        if(make_swap){\n            int aux=sigma[ i ];\n            sigma[ i ] =sigma[ j ];\n            sigma[ j ] =aux;\n        }\n        //gen.print_int_vector(sigma, n_);\n        if(sample>=burning_period_samples){\n            samples[sample-burning_period_samples]  = new int[ n_ ];\n            for (int i = 0 ; i < n_; i ++ )   samples[sample-burning_period_samples][ i ] =sigma[ i ];\n        }\n    }\n    delete [] sigma;\n}\n\n\nlong double Cayley::get_likelihood(int m, int** samples, int model, int * sigma_0){\n    double  psi;\n    int     dist    = 0 ;\n    double  * theta = new double[ n_ ];\n    long double loglikelihood;\n\n    if(model == MALLOWS_MODEL){\n        Newton_raphson newton(n_);\n        double  *psi_vec = new double [n_];\n        dist = distance_to_sample(samples, m, sigma_0);\n        theta[ 0 ] = newton.Newton_raphson_method((double)dist/m, -10.001,CAYLEY_DISTANCE, MALLOWS_MODEL, -1, NULL);\n         for (int i = 1 ; i < n_ -1; i++) theta[ i ] = theta[ 0 ];\n         psi = calculate_psi(theta, psi_vec);\n         delete [] psi_vec;\n         loglikelihood = - theta[0] * dist - m * log (psi);\n    }else{\n        int *x = new int[ n_ ], *x_acumul = new int[ n_ ], *inv = new int[ n_ ], *comp = new int[ n_ ];\n        for(int i = 0 ; i < n_ ; i++) x_acumul[ i ] = 0;\n        for(int i = 0 ; i < n_ ; i++) inv [ sigma_0[ i ] - 1 ] = i + 1;\n        for (int i = 0 ; i < m; i ++ ){\n            for(int j = 0 ; j < n_ ; j ++) comp[ j ] = samples[ i ] [ inv [ j ] - 1 ];\n            perm2dist_decomp_vector(comp, x);\n            for(int j = 0 ; j < n_ - 1 ; j++) x_acumul[ j ] += x[ j ];\n        }\n        loglikelihood = get_theta_log_likelihood(m, x_acumul, NULL, theta);//theta is an array of length n\n        delete [] x;\n        delete [] x_acumul;\n        delete [] inv;\n        delete [] comp;\n    }\n    delete [] theta;\n    return loglikelihood;\n}\n\n\n void Cayley::estimate_theta(int m, int *sigma_0, int **samples, int model, double *theta){\n     if(model == MALLOWS_MODEL){\n        int dist = distance_to_sample(samples, m, sigma_0);\n        Newton_raphson newton(n_);\n        theta[0] = newton.Newton_raphson_method((double)dist/m, -10.001,CAYLEY_DISTANCE, MALLOWS_MODEL, -1, NULL);\n    }else{\n        int *x = new int[ n_ ], *x_acumul = new int[ n_ ], *inv = new int[ n_ ], *comp = new int[ n_ ];\n        for(int i = 0 ; i < n_ ; i++) x_acumul[ i ] = 0;\n        for(int i = 0 ; i < n_ ; i++) inv [ sigma_0[ i ] - 1 ] = i + 1;\n        for (int i = 0 ; i < m; i ++ ){\n            for(int j = 0 ; j < n_ ; j ++) comp[ j ] = samples[ i ] [ inv [ j ] - 1 ];\n            perm2dist_decomp_vector(comp, x);\n            for(int j = 0 ; j < n_ - 1 ; j++) x_acumul[ j ] += x[ j ];\n        }\n        double l = get_theta_log_likelihood(m, x_acumul, NULL, theta);//theta is an array of length n\n        cout<<\"likeli(Cayley::estimate_theta) \"<<l<<endl;\n        delete [] x;\n        delete [] x_acumul;\n        delete [] inv;\n        delete [] comp;\n    }\n}\n\nint Cayley::distance_to_sample(int **samples, int m, int *sigma){\n    int distance= 0;\n    int *comp = new int[ n_ ], *sigma_inv = new int[ n_ ];\n    for(int j = 0 ; j < n_ ; j ++) sigma_inv[sigma[ j ] - 1 ] = j + 1;\n    for(int s = 0 ; s < m ; s ++){\n        for(int i = 0 ; i < n_ ; i ++) comp[ i ] = samples[ s ][ sigma_inv [ i ] - 1 ];\n        distance += perm2dist_decomp_vector(comp, NULL);\n    }\n    delete []sigma_inv;\n    delete []comp;\n    return distance ;\n}\n\nlong double Cayley::count_permus_by_x(int *x){\n    int d = 0, c_len = 0;\n    for(int i = 0 ; i < n_ ; i++) if(x[ i ] == 1 ) d++;\n    c_len = n_ - d;\n    long double *c = new long double[c_len];\n    for ( int i = 0 ; i < c_len ; i ++) c[ i ] = 0 ;\n    int *k= new int[ n_ ], k_in=c_len;\n    for( int i = n_ - 1 ; i >= 0 ; i --){// first top cycle item with which can be joind¡ed in the cycle\n        if ( x[ i ] == 0 )k_in --;\n        k[ i ] = k_in;\n    }\n    long double l = count_permus_by_x_core(0, x, c, c_len, k);\n    delete [] c;\n    delete [] k;\n    return l;\n}\n\nlong double Cayley::count_permus_by_x_core(int index, int *x, long double *c, int c_len, int *k){\n    Generic gen;\n    long double l = 0, p = 1;\n    if( index == n_ ) {\n        for(int i = 0 ; i < c_len ; i ++) p *= gen.factorial(c[ i ]);\n        return p ;\n    }\n    if (x[index] == 0) return count_permus_by_x_core(index + 1, x, c , c_len, k);\n    for(int i = k[index] ; i < c_len ; i ++){\n        long double *c_i = new long double[c_len];\n        for(int j = 0 ; j < c_len ; j ++) c_i[ j ] = c[ j ];\n        c_i[ i ] ++;\n        l += count_permus_by_x_core(index+1, x, c_i, c_len, k);\n        delete [] c_i;\n    }\n    return l;\n}\n\ndouble Cayley::estimate_consensus_exact_gmm(int m, int **samples, int*sigma_0_ini, int *sigma_0){\n    int     ** samples_inv = new int*[ m ];\n    int     ** samples_inv_freq = new int*[ n_ ];\n    int     * x_acum = new int[ n_ ];\n    int     * sigma_0_aux = new int[ n_ ];\n    int     * sigma_0_inv_aux = new int[ n_ ];\n    double  likelihood = -DBL_MAX;\n\n    \n    Generic gen;\n    for (int i = 0 ; i < m; i ++ ){\n        samples_inv[ i ]  = new int[ n_ ];\n        gen.invert(n_, samples[ i ], samples_inv[ i ]);\n    }\n    for (int i = 0 ; i < n_; i ++ ){ //ini\n        samples_inv_freq[ i ]  = new int[ n_ ];\n        for(int j= 0;j<n_;j++)samples_inv_freq[ i ][ j ] = 0;\n        x_acum[ i ] = 0;\n    }\n    for(int i = 0 ; i < m; i ++ )for(int j= 0;j<n_;j++)samples_inv_freq[ j ][samples_inv[ i ][ j ]-1]++;\n    for (int i = 0 ; i < n_; i ++ ) {sigma_0_aux[ i ] = -1 ; sigma_0_inv_aux[ i ] = -1 ;}\n    \n    //bounds\n    estimate_consensus_approx(GENERALIZED_MALLOWS_MODEL , m, samples, sigma_0);\n    likelihood = get_likelihood(m , samples , GENERALIZED_MALLOWS_MODEL , sigma_0);\n    \n    if ( sigma_0_ini != NULL ){\n        //obtain the likelihod of the proposed sigma_0_ini.\n        double like_ini = get_likelihood(m , samples , GENERALIZED_MALLOWS_MODEL , sigma_0_ini);\n        //check both solutions: the proposed sigma_0_ini vs. the approx. Discard the worse\n        if (like_ini > likelihood) {\n            likelihood = like_ini;\n            for (int i = 0 ; i < n_ ; i++) sigma_0[ i ] = sigma_0_ini[ i ];\n        }\n    }\n    \n    \n    double visited_nodes = estimate_consensus_exact_gmm_core(m, 0 , samples, samples_inv, samples_inv_freq,\n                                                   x_acum, sigma_0_aux, sigma_0_inv_aux, 0, sigma_0, &likelihood);\n    //delete\n    for (int i = 0 ; i < m; i ++ ) delete []samples_inv[ i ];\n    delete [] samples_inv;\n    for (int i = 0 ; i < n_; i ++ ) delete []samples_inv_freq[ i ];\n    delete [] samples_inv_freq;\n    delete [] x_acum;\n    delete [] sigma_0_aux;\n    delete [] sigma_0_inv_aux;\n    return visited_nodes;\n}\n\ndouble Cayley::estimate_consensus_exact_gmm_core(int m, int pos, int ** samples, int ** samples_inv, int **samples_inv_freq,\n                                       int * x_acum, int * current_sigma, int * current_sigma_inv, double current_likeli_bound,\n                                       int * best_sigma, double * best_likeli){\n    if(pos == n_ && current_likeli_bound >= (*best_likeli)){\n        for (int i = 0 ; i < n_; i ++ )best_sigma[ i ] =current_sigma[ i ];\n        (*best_likeli)=current_likeli_bound;\n        return 1;\n    }\n    double visited_nodes= 0;\n    bool trace=true;\n    int *x_acum_var = new int[ n_ ];\n    double *theta_estim = new double[ n_ ];\n    for(int it= 0;it<n_;it++){//sigmaInv(pos)=it\n        if(current_sigma[it] ==-1){\n            int xIncr= 0;\n            current_sigma_inv[pos] =it+1;\n            current_sigma[it] =pos+1;\n            int *pos_swaps = new int[ m ];\n            for(int s= 0;s<m;s++){\n                pos_swaps[ s ] =-1;\n                if(samples[ s ][it] != current_sigma[it]){\n                    int x= samples[ s ][it];\n                    int y= samples_inv[ s ][pos]-1;\n                    samples[ s ][it] =pos+1;\n                    samples[ s ][y] =x;\n                    samples_inv[ s ][pos] =it+1;\n                    samples_inv[ s ][x-1] =y+1;\n                    pos_swaps[ s ] =y;\n                    xIncr++;\n                    samples_inv_freq[pos][y]--;\n                    samples_inv_freq[x-1][it]--;\n                    samples_inv_freq[pos][it]++;\n                    samples_inv_freq[x-1][y]++;\n                }\n                if(false){\n                    for (int k = 0 ; k < n_ ; k ++ ) cout<<samples[ s ][ k ]<<\" \";cout<<\" sample \";\n                    for (int k = 0 ; k < n_ ; k ++ ) cout<<samples_inv[ s ][ k ]<<\" \";cout<<\" sampInv \";\n                    for (int i = 0 ; i < n_ ; i ++ ) cout<<current_sigma_inv[ i ]<<\" \";cout<<\" sigmaInv \";\n                    for (int i = 0 ; i < n_ ; i ++ ) cout<<current_sigma[ i ]<<\" \";cout<<\" sigma (v3)\"<<endl;;}\n                //in this case the distance has incresed in one, x[maxItemInCylce] was 0 and now = 1\n            }\n            \n            int *xbound = new int[ n_ ];\n            for (int i = 0 ; i < n_; i ++ )xbound[ i ] = 0;\n            get_x_lower_bound_freq(m, samples_inv_freq, pos+1, xbound);\n            for (int i = 0 ; i < n_; i ++ ) x_acum_var[ i ] =x_acum[ i ];\n            x_acum_var[pos] += xIncr;\n            double likeliBound=get_theta_log_likelihood(m, x_acum_var, xbound, theta_estim);\n            if(trace){for (int i = 0 ; i < n_; i ++ ) cout<<xbound[ i ]<<\" \";cout<<\" xbound, pos: \"<<pos<<\" sigma_inv \"; \n                      for (int i = 0 ; i < n_ ; i ++ ) cout<<current_sigma_inv[ i ]<<\" \";cout<<\" x \";\n                      cout<<\"[\";\n                      for (int i = 0 ; i < n_ ; i ++ ) cout<<x_acum_var[ i ]<<\", \";cout<<\" 0], \"<<endl;}\n            delete []xbound;\n            \n            if(likeliBound >= (*best_likeli) )\n                visited_nodes += estimate_consensus_exact_gmm_core(m, pos+1, samples, samples_inv, samples_inv_freq, x_acum_var, current_sigma, current_sigma_inv, likeliBound, best_sigma, best_likeli);\n            //else {cout<<\"bounded at \"<<pos<<\" - \";for (int i = 0 ; i < n; i ++ )cout<<current_sigma[ i ]<<\" \";cout<<endl;}\n            current_sigma_inv[pos] =-1;\n            current_sigma[it] =-1;\n            for (int s = 0 ; s < m ; s ++){\n                if(pos_swaps[ s ] != -1){\n                    int y=pos_swaps[ s ];\n                    int x=samples[ s ][y];\n                    samples[ s ][it] =x;\n                    samples[ s ][y] =pos+1;\n                    samples_inv[ s ][pos] =y+1;\n                    samples_inv[ s ][x-1] =it+1;\n                    pos_swaps[ s ] =-1;\n                    samples_inv_freq[pos][y]++;\n                    samples_inv_freq[x-1][it]++;\n                    samples_inv_freq[pos][it]--;\n                    samples_inv_freq[x-1][y]--;\n                }\n            }\n            delete [] pos_swaps;\n        }\n    }\n    delete [] theta_estim;\n    delete [] x_acum_var;\n    return visited_nodes+1;\n}\n\ndouble Cayley::estimate_consensus_exact_mm(int m, int **samples, int*sigma_0_ini, int *sigma_0){\n    int **samples_inv = new int*[ m ];\n    int *x_acum = new int[ n_ ];\n    int *sigma_0_aux = new int[ n_ ];\n    int *sigma_0_inv_aux = new int[ n_ ];\n    Generic gen;\n    for (int i = 0 ; i < m; i ++ ){\n        samples_inv[ i ]  = new int[ n_ ];\n        gen.invert(n_, samples[ i ], samples_inv[ i ]);\n    }\n    double best_distance = (n_ - 1) * m;//maximum\n    for (int i = 0 ; i < n_; i ++ ) {\n        sigma_0_aux[ i ] =-1;\n        sigma_0_inv_aux[ i ] =-1;\n        x_acum[ i ] = 0;\n    }\n    //bounds\n    estimate_consensus_approx(MALLOWS_MODEL , m, samples, sigma_0);\n    best_distance = distance_to_sample(samples , m , sigma_0);\n    \n    if ( sigma_0_ini != NULL ){\n        //obtain the likelihod of the proposed sigma_0_ini.\n        double dist_ini = distance_to_sample(samples , m , sigma_0_ini);\n        //check both solutions: the proposed sigma_0_ini vs. the approx. Discard the worse\n        if (dist_ini < best_distance) {\n            best_distance = dist_ini;\n            for (int i = 0 ; i < n_ ; i++) sigma_0[ i ] = sigma_0_ini[ i ];\n        }\n    }\n\n    double visited_nodes = estimate_consensus_exact_mm_core(m, 0 , samples, samples_inv, x_acum, sigma_0_aux, sigma_0_inv_aux, 0, sigma_0, &best_distance);\n    for (int i = 0 ; i < m; i ++ ) delete []samples_inv[ i ];\n    delete [] samples_inv;\n    delete [] x_acum;\n    delete [] sigma_0_aux;\n    delete [] sigma_0_inv_aux;\n    return visited_nodes;\n}\ndouble Cayley::estimate_consensus_exact_mm_core(int m, int pos, int ** samples, int ** samples_inv, int * x_acum,  int * current_sigma,\n                              int * current_sigma_inv, double current_dist_bound, int *best_sigma, double *best_dist){\n    if(pos == n_ && current_dist_bound <= (*best_dist)){\n        for (int i = 0 ; i < n_; i ++ )best_sigma[ i ] =current_sigma[ i ];\n        (*best_dist)=current_dist_bound;\n        return 1;\n    }\n    double visited_nodes= 0;\n    bool trace=false, enc=false;\n    int *x_acum_var = new int[ n_ ], *candVec = new int[ n_ ];\n    int cand=n_;\n    int *freq = new int[ n_ ]; for (int i = 0 ; i < n_; i ++ )freq[ i ] = 0;\n    for(int s = 0;(!enc && s<m );s++){\n        if((freq[samples_inv[ s ][pos]-1]++) > (m/2)){\n            candVec[0] =samples_inv[ s ][pos]-1;\n            enc=true;\n            cand=1;\n        }\n    }\n    if(!enc){\n        for(int it = 0 ; it < n_ ; it ++) candVec[ it ] = it;\n        cand=n_;\n    }\n    for(int index = 0;index < cand ; index++){//sigmaInv(pos)=it\n        int it = candVec[index];\n        if(current_sigma[it] ==-1){\n            int x_incr= 0;\n            current_sigma_inv[pos] =it+1;\n            current_sigma[it] =pos+1;\n            int *pos_swaps = new int[ m ];\n            //for (int i = 0 ; i < m; i ++ )posSwaps[ i ] =-1;\n            for(int s= 0;s<m;s++){\n                pos_swaps[ s ] =-1;\n                if(samples[ s ][it] != current_sigma[it]){\n                    int x = samples[ s ][it];\n                    int y = samples_inv[ s ][pos]-1;\n                    samples[ s ][it] = pos+1;\n                    samples[ s ][y] = x;\n                    samples_inv[ s ][pos] = it + 1;\n                    samples_inv[ s ][x-1] = y + 1;\n                    pos_swaps[ s ] =y;\n                    x_incr++;\n                }\n                if(trace)\n                {   for (int k = 0 ; k < n_ ; k ++) cout<<samples[ s ][ k ]<<\" \";cout<<\" sample \";\n                    for (int k = 0 ; k < n_ ; k ++) cout<<samples_inv[ s ][ k ]<<\" \";cout<<\" sampInv \";\n                    for (int i = 0 ; i < n_; i ++ ) cout<<current_sigma_inv[ i ]<<\" \";cout<<\" sigmaInv \";\n                    for (int i = 0 ; i < n_; i ++ ) cout<<current_sigma[ i ]<<\" \";cout<<\" sigma (v3)\"<<endl;;}\n                //in this case the distance has incresed in one, x[maxItemInCylce] was 0 and now = 1\n            }\n            \n            double distance_bound = 0;\n            int *xbound = new int[ n_ ];for (int i = 0 ; i < n_; i ++ )xbound[ i ] = 0;\n            get_x_lower_bound(m, samples_inv, pos+1, xbound);\n            if(trace){for (int i = 0 ; i < n_; i ++ ) cout<<xbound[ i ]<<\" \";cout<<\" xbound, pos: \"<<pos<<endl;}\n            for(int i=pos+1 ; i < n_; i ++ ) distance_bound+=xbound[ i ];\n            delete []xbound;\n            for (int i = 0 ; i < n_; i ++ ){\n                x_acum_var[ i ] =x_acum[ i ];\n                distance_bound += x_acum_var[ i ];\n            }\n            x_acum_var[pos] += x_incr;\n            distance_bound += x_incr;\n            \n            if(distance_bound <= (*best_dist)) visited_nodes+=estimate_consensus_exact_mm_core(m, pos+1, samples, samples_inv, x_acum_var, current_sigma, current_sigma_inv, distance_bound, best_sigma, best_dist);\n            //else {cout<<\"bounded at \"<<pos<<\" - \";for (int i = 0 ; i < n; i ++ )cout<<current_sigma[ i ]<<\" \";cout<<endl;}\n            current_sigma_inv[pos] =-1;\n            current_sigma[it] =-1;\n            for(int s= 0;s<m;s++){\n                if(pos_swaps[ s ] != -1){\n                    int y = pos_swaps[ s ];\n                    int x = samples[ s ][y];\n                    samples[ s ][it] =x;\n                    samples[ s ][y] =pos+1;\n                    samples_inv[ s ][pos] =y+1;\n                    samples_inv[ s ][x-1] =it+1;\n                    pos_swaps[ s ] =-1;\n                }\n            }\n            delete [] pos_swaps;\n        }\n    }\n    \n    delete [] x_acum_var;\n    delete [] candVec;\n    delete [] freq;\n    return visited_nodes + 1 ;\n}\n\nvoid Cayley::estimate_consensus_approx(int model, int m, int **samples, int *sigma_0){\n    int ** samples_inv = new int*[ m ];\n    int ** samples_copy = new int*[ m ];\n    for (int i = 0 ; i < m; i++) {\n        samples_copy[ i ] = new int[ n_ ];\n        samples_inv [ i ] = new int[ n_ ];\n        for(int j = 0 ; j < n_ ; j ++) {samples_inv[ i ][ samples[ i ][ j ] - 1 ] = j + 1;samples_copy[ i ][ j ] = samples[ i ][ j ];}\n    }\n    double bl_data;\n    double *best_likeli = &bl_data;\n    if( model == MALLOWS_MODEL )\n        estimate_consensus_approx_mm(m, samples_copy, samples_inv, sigma_0, best_likeli);\n    else\n        estimate_consensus_approx_gmm(m, samples_copy, samples_inv, sigma_0, best_likeli);\n    variable_neighborhood_search(m, samples, sigma_0, model , best_likeli);\n    for (int i = 0 ; i < m; i++) {\n        delete [] samples_inv[ i ];\n        delete [] samples_copy[ i ];\n    }\n    delete [] samples_copy;\n    delete [] samples_inv;\n}\n\nvoid Cayley::estimate_consensus_approx_gmm(int m, int **samples_copy, int **samples_inv, int *sigma_0, double *best_likeli){\n    // pre: sigma, sigmaInv =-1\n    int *freq = new int[ n_ ];     \n    int *x_acum = new int[ n_ ];   for (int i = 0; i < n_; i++) x_acum[ i ] = 0;\n    int * sigma_0_inv = new int[ n_ ];\n    \n    for (int i = 0; i < n_; i++){ sigma_0[ i ] = -1;sigma_0_inv[ i ] = -1;}\n\n    for (int item = 0 ; item < n_ ; item ++){\n        //for(int s= 0;s<m;s++){  for (int i = 0 ; i < n; i ++ )cout<<samples[ s ][ i ]<<\" \";cout<<\"samples  trace  1\"<<endl;}\n        for (int i = 0; i < n_; i++) freq[ i ] = 0;\n        int max_freq = 0;\n        int pj = -1; // 0..n-1\n        //for(int s= 0;s<m;s++){  for (int i = 0 ; i < n; i ++ )cout<<samples[ s ][ i ]<<\" \";cout<<\"samples  trace  2\"<<endl;}\n        for (int s = 0;  s < m; s++){\n            freq[ samples_inv[ s ][item] - 1] ++;\n            if ((freq[ samples_inv[ s ][item] - 1]) > max_freq){\n                max_freq = freq[ samples_inv[ s ][item] - 1];\n                pj = samples_inv[ s ][item] - 1;\n            }\n        }\n        //for (int i = 0 ; i < n; i ++ ){for(int j= 0;j<n;j++)cout<<freq[ i ][ j ]<<\" \";cout<<endl;}\n        sigma_0_inv[item] = pj + 1;\n        sigma_0 [pj] = item + 1;\n        for (int s = 0; s < m; s++) {\n            if (samples_copy[ s ][pj] != item + 1) {//swap\n                int x = samples_copy[ s ][pj];\n                int y = samples_inv[ s ][item] - 1;\n                samples_copy[ s ][pj] = item + 1;\n                samples_copy[ s ][y] = x;\n                samples_inv [ s ][item] = pj + 1;\n                samples_inv [ s ][x - 1] = y + 1;\n                x_acum[ item ]++;\n            }\n        }\n    }\n    \n    double *theta = new double[ n_ ];\n    *best_likeli = get_theta_log_likelihood(m, x_acum, NULL, theta);\n    delete [] theta;\n    delete [] x_acum;\n    delete [] sigma_0_inv;\n    delete [] freq;\n}\n\nvoid Cayley::estimate_consensus_approx_mm(int m, int **samples_copy, int **samples_inv, int *sigma_0, double *best_distance){\n    // pre: sigma, sigmaInv =-1\n    int distance_increase = 0, remaining = n_;\n    int **freq = new int*[ n_ ];for (int i = 0; i < n_; i++) freq[ i ] = new int[ n_ ];\n    \n    for (int i = 0; i < n_; i++) sigma_0[ i ] = -1;\n    do{ //for(int s= 0;s<m;s++){  for (int i = 0 ; i < n; i ++ )cout<<samples[ s ][ i ]<<\" \";cout<<\"samples  trace  1\"<<endl;}\n        for (int i = 0; i < n_; i++)\n            for (int j = 0; j < n_; j++)freq[ i ][ j ] = 0;\n        int max_freq = 0;\n        int pi = -1, pj = -1; // 0..n-1\n        bool dirty_items = true ; //si hay alguno q aparezca >m/2 veces?\n        \n        //for(int s= 0;s<m;s++){  for (int i = 0 ; i < n; i ++ )cout<<samples[ s ][ i ]<<\" \";cout<<\"samples  trace  2\"<<endl;}\n        Generic gen;\n        //gen.print_int_matrix(samples_copy, m, n_);\n        for (int s = 0; dirty_items && s < m; s++)\n            for (int i = 0; ( dirty_items && i < n_ ) ; i++){\n                //gen.print_int_matrix(freq, n_, n_);\n                if (sigma_0[ i ] == -1) (freq[ i ][samples_copy[ s ][ i ] - 1])++;\n                if ((freq[ i ][samples_copy[ s ][ i ] - 1]) > max_freq){\n                    max_freq = (freq[ i ][samples_copy[ s ][ i ] - 1]);\n                    pi = i;\n                    pj = samples_copy[ s ][ i ] - 1;\n                    if (max_freq > m/2 ) dirty_items = false ;\n                }\n            }\n        //for (int i = 0 ; i < n; i ++ ){for (int j = 0 ; j < n;j++)cout<<freq[ i ][ j ]<<\" \";cout<<endl;}\n        sigma_0[pi] = pj + 1;\n        for (int s = 0; s < m; s++) {\n            if (samples_copy[ s ][pi] != pj + 1) {//////////////swap\n                //swapSamplesDo(s, pi, pj, samples, samples_inv, posSwap);\n                int x = samples_copy[ s ][pi];\n                int y = samples_inv[ s ][pj] - 1;\n                samples_copy[ s ][pi] = pj + 1;\n                samples_copy[ s ][y] = x;\n                samples_inv[ s ][pj] = pi + 1;\n                samples_inv[ s ][x - 1] = y + 1;\n                distance_increase++;\n            }\n        }\n        remaining--;\n    }while(remaining > 0) ;\n    (*best_distance) = distance_increase;\n    for (int i = 0 ; i < n_ ; i ++) delete [] freq[ i ];\n    delete [] freq;\n}\n\nvoid Cayley::variable_neighborhood_search(int m, int **samples, int *sigma, int model, double *f_eval){\n    bool improve;\n    do{\n        double f_eval_ini = (*f_eval);\n        //cout<<\" distance ini\"<<(*f_eval)<<endl;\n        if( model == MALLOWS_MODEL ) local_search_swap_mm  (m, samples, sigma, f_eval);\n        else local_search_swap_gmm  (m, samples, sigma, f_eval);\n        //cout<<\" distance new swap \"<<(*f_eval)<<endl;\n        local_search_insert(m, samples, sigma, model, f_eval);\n        //cout<<\" distance new ins \"<<(*f_eval)<<endl;\n        improve=false ;\n        if( model == MALLOWS_MODEL  && (f_eval_ini) > *f_eval ) improve = true;\n        if( model == GENERALIZED_MALLOWS_MODEL  && (f_eval_ini) < *f_eval ) improve = true;\n    }while(improve);\n}\n\nvoid Cayley::local_search_swap_mm(int m, int **samples, int *sigma_0, double *f_eval){\n    int ** samples_comp = new int*[ m ];\n    for (int s = 0 ; s < m; s++)  samples_comp[ s ] = new int[ n_ ];\n    int *sigma_0_inv = new int[ n_ ];\n    int *cycle_items = new int [n_ ], *cycle_index = new int[ n_];\n    int **same_cycle = new int*[ n_ ];\n    for (int i = 0 ; i < n_ ; i ++){ same_cycle[ i ] = new int[ n_ ]; for (int j = 0 ; j < n_ ; j++) same_cycle[ i][ j ] = 0;}\n    Generic gen;\n    int index_i,index_j, distance_variation = 0;\n    for(int i = 0 ; i < n_ ; i ++) sigma_0_inv[ sigma_0 [ i ] - 1 ] = i + 1;\n    bool improve;\n    do {//iterating use just sigma_0_inv\n        int max_freq = 0;\n        for (int i = 0 ; i < n_ ; i ++) for (int j = 0 ; j < n_ ; j++) same_cycle[ i][ j ] = 0;\n        for (int s = 0 ; s < m; s++) {\n            for(int j = 0 ; j < n_ ; j ++ ) samples_comp[ s ][ j ] = samples[ s ][ sigma_0_inv [ j ] - 1 ];\n            get_cycles(samples_comp[ s ], cycle_items, cycle_index);\n            //cout<<\"Cycles \";gen.print_int_vector(cycle_items, n_); gen.print_int_vector(cycle_index, n_);\n            for ( int i = 0 ; i < n_ ; i ++){\n                for (int j = i + 1; j < n_ && (cycle_index[ i ] == cycle_index[ j ]) ; j++){\n                    int max, min; // for a triangular matrix\n                    if (cycle_index [ i ] > cycle_index[ j ]){ max = cycle_items[ i ] - 1; min  = cycle_items[ j ]-1;}\n                    else {min  = cycle_items[ i ]-1; max  = cycle_items[ j ]-1;}\n                    same_cycle[ min ][ max ] ++;\n                    if (max_freq < same_cycle[ min ][ max ] ) {\n                        max_freq = same_cycle[ min ][ max ];\n                        index_i = min;\n                        index_j = max;\n                    }\n                    //if (max_freq > m)//ERROR\n                    //{ cout<<\"Cycles \";gen.print_int_vector(cycle_items, n_); gen.print_int_vector(cycle_index, n_);gen.print_int_matrix(same_cycle, n_, n_);}\n                }\n            }\n        }\n        //there are m oermus, max_freq of them are going to decrease dist in 1. (m-max_freq) are going to incresse\n        distance_variation = m - 2 * max_freq;\n        \n        improve = false;\n        if( distance_variation < 0 ) {\n            improve = true;\n            int aux = sigma_0_inv[index_i];\n            sigma_0_inv[index_i] = sigma_0_inv[index_j];\n            sigma_0_inv[index_j] = aux;\n            \n            (*f_eval) += distance_variation;\n            for(int i = 0 ; i < n_ ; i ++) sigma_0[ sigma_0_inv[ i ] - 1 ] = i + 1;\n            \n        }\n        \n        //cout<<\"trace in local search swap, distance variation \"<<distance_variation<<\" mxa freq \"<<max_freq<<endl;\n    } while (improve );\n    \n    delete [] sigma_0_inv;\n    delete [] cycle_index;\n    delete [] cycle_items;\n    for (int i = 0 ; i < n_ ; i++) delete [] same_cycle[ i ];\n    delete [] same_cycle;\n    for (int i = 0 ; i < m ; i++)  delete [] samples_comp[ i ];\n    delete [] samples_comp;\n}\n\nvoid Cayley::local_search_swap_gmm(int m, int **samples, int *sigma_0, double *f_eval){\n    int ** samples_comp = new int*[ m ];\n    for (int s = 0 ; s < m; s++)  samples_comp[ s ] = new int[ n_ ];\n    int *sigma_0_inv = new int[ n_ ];\n    int *x_acum = new int [n_ ], *x_acum_var = new int[ n_], *x = new int[ n_], *best_x_acum = new int[ n_ ], *x_test = new int[ n_ ];\n    double *theta = new double [ n_ ];\n    Generic gen;\n    int index_i,index_j;\n    for(int i = 0 ; i < n_ ; i ++) {sigma_0_inv[ sigma_0 [ i ] - 1 ] = i + 1;x_acum[ i ] = 0;x_acum_var[ i ] = 0;}\n    bool improve;\n    for (int s = 0 ; s < m; s++){\n        for(int j = 0 ; j < n_ ; j ++ )\n            samples_comp[ s ][ j ] = samples[ s ][ sigma_0_inv [ j ] - 1 ];\n        perm2dist_decomp_vector(samples_comp[ s ], x);\n        for(int j = 0 ; j < n_ ; j ++ ) x_acum[ j ] += x[ j ];\n    }\n\n    do {//iterating use just sigma_0_inv\n        double best_like = 0;\n        for (int iter_i = 0; iter_i < n_ - 1 ; iter_i++) {\n            for (int iter_j = iter_i + 1 ; iter_j < n_ ; iter_j++) {\n                //test swap i j on samples_comp\n                for(int k = 0 ; k < n_ ; k ++) {x_acum_var[ k ] = 0;}\n                for (int s = 0 ; s < m ; s++) {\n                    int max_i, max_j;\n                    //cout<<\"sample \"; Generic gen; gen.print_int_vector(samples_comp[ s ], n_);\n                    if (same_cycle(iter_i, iter_j, samples_comp[ s ])){\n                        get_max_item_in_future_cycles(samples_comp[ s ], iter_i, iter_j, &max_i , &max_j);\n                        x_acum_var[(max_i < max_j ? max_i : max_j )] --;\n                        //cout<<\" resta en \"<<(max_i < max_j ? max_i : max_j )<<endl;\n                    }else {\n                        get_max_item_in_current_cycle(samples_comp[ s ], iter_i, &max_i );\n                        get_max_item_in_current_cycle(samples_comp[ s ], iter_j, &max_j );\n                        x_acum_var[(max_i < max_j ? max_i : max_j )] ++;\n                        //cout<<\" suma en \"<<(max_i < max_j ? max_i : max_j )<<endl;\n                    }\n                }\n                //////test\n                double like = get_theta_log_likelihood(m, x_acum, x_acum_var, theta);\n                if ( like > best_like || best_like == 0){\n                    for(int i = 0 ; i < n_ ; i ++) best_x_acum[ i ] = x_acum_var[ i ];\n                    best_like = like;\n                    index_i = iter_i;\n                    index_j = iter_j;\n                }\n            }\n        }\n        //there are m oermus, max_freq of them are going to decrease dist in 1. (m-max_freq) are going to incresse\n        improve = false;\n        \n\n        if( best_like > *f_eval ) {\n            improve = true;\n            (*f_eval) = best_like;\n            int aux = sigma_0_inv[index_i];\n            sigma_0_inv[index_i] = sigma_0_inv[index_j];\n            sigma_0_inv[index_j] = aux;\n            for(int i = 0 ; i < n_ ; i ++) sigma_0[ sigma_0_inv[ i ] - 1 ] = i + 1;\n            for (int s = 0 ; s < m ; s++) {\n                int aux = samples_comp[ s ][index_i];\n                samples_comp [ s ][index_i] = samples_comp[ s ][index_j];\n                samples_comp [ s ][index_j] = aux;\n            }\n            for(int j = 0 ; j < n_ ; j ++ ) x_acum[ j ] += best_x_acum[ j ];\n            //test a ver si son iguales\n        }\n        //cout<<\"trace in local search swap, distance variation \"<<distance_variation<<\" mxa freq \"<<max_freq<<endl;\n    } while (improve );\n\n\n    delete [] theta;\n    delete [] best_x_acum;\n    delete [] sigma_0_inv;\n    delete [] x_acum;\n    delete [] x_acum_var;\n    delete [] x;\n    delete [] x_test;\n    for (int i = 0 ; i < m ; i++)  delete [] samples_comp[ i ];\n    delete [] samples_comp;\n}\n\nvoid Cayley::local_search_insert (int m, int **samples, int *sigma_0, int model, double *f_eval){\n    int *best_sol = new int[ n_ ], *next_sol = new int[ n_ ], *x_acumul = new int[ n_ ], *x = new int[ n_ ];\n    double * theta = new double[ n_ ];\n    double best_eval= 0;\n    bool better;\n    Generic gen;\n    do {\n        better = false;\n        best_eval = 0;\n        for(int i = 0 ; i < n_ ; i ++){\n            for ( int j = 0 ; j < n_ ; j++){\n                if(i != j){\n                    gen.insert_at (sigma_0, n_, i, j, next_sol);\n                    if(model == MALLOWS_MODEL){\n                        int dist = distance_to_sample(samples, m , next_sol);\n                        if ( dist < best_eval || best_eval == 0){\n                            best_eval = (double )dist;\n                            for (int i = 0 ; i < n_ ; i ++) best_sol [ i ] = next_sol[ i ];\n                        }\n                    }else {\n                        for(int index = 0 ; index < n_ ; index ++ ) x_acumul[ index ] = 0;\n                        for (int s = 0 ; s < m; s++){\n                            perm2dist_decomp_vector(samples[ s ], x);\n                            for(int index = 0 ; index < n_ ; index ++ ) x_acumul[index] += x[index];\n                        }\n                        double likeli = get_theta_log_likelihood(m,x_acumul, NULL, theta);\n                        if (likeli > best_eval || best_eval == 0) {\n                            best_eval = likeli;\n                            for (int i = 0 ; i < n_ ; i ++) best_sol [ i ] = next_sol[ i ];\n                        }\n                    }\n                }\n            }\n        }\n        \n        if( (model == MALLOWS_MODEL && best_eval < *f_eval ) || ( model == GENERALIZED_MALLOWS_MODEL && best_eval > *f_eval ) ){\n            *f_eval = best_eval;\n            for (int i = 0 ; i < n_ ; i ++) sigma_0 [ i ] = best_sol[ i ];\n            better = true;\n        }\n    } while (better);\n    delete [] next_sol;\n    delete [] theta;\n    delete [] x;\n    delete [] x_acumul;\n    delete [] best_sol;\n}\n",
    "created" : 1441816930999.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "513230042",
    "id" : "9EEC8B86",
    "lastKnownWriteTime" : 1445948189,
    "path" : "~/Dropbox/permus/prj/R/PerMallows/src/Cayley.cpp",
    "project_path" : "src/Cayley.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}