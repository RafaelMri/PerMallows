{
    "contents" : "//\n//  Newton_raphson.cpp\n//  perms_mallows\n//\n//  Created by Ekhine Irurozki on 24/06/13.\n//  Copyright (c) 2013 Ekhine Irurozki. All rights reserved.\n//\n\n\n//#include \"Ulam.hpp\"\n#define MAXIT 200\n#define ALF 1.0e-4 \n#define TOLX 1.0e-7\n#define MAXITS 200\n#define EPS2 1.0e-4\n#define TOLF 1.0e-4\n#define TOLMIN 1.0e-6\n#define STPMX 100.0\n\n#include \"Newton_raphson.h\"\n#include <iostream>\n#include <math.h>\n#include \"Generic.h\"\n#include <cmath>\n#include <float.h>\n#include <cstring>\n#include <math.h>\n#include \"Hamming.h\"\n\n\n#define FREERETURN {free_matrix(fjac,1,n,1,n);free_vector(fvec,1,n);\\\nfree_vector(p,1,n);free_ivector(indx,1,n);return;}\n/*\n * Estimates theta parameters by means of running newton iterative algorithm.\n */\ndouble Newton_raphson::Newton_raphson_method( double dAvg_val, double initialGuess, int distanceModel_val, int model, int j_index, long double*count) {\n    count_ = count;//count of num permus for ulam\n    double xacc = 0.000001;\n//    n_ = n_val;\n    j_index_ = j_index; // for kendall GMM\n    model_ =  model;\n    dist_avg_=dAvg_val;\n    UPPER_THETA=5;\n    distance_id_=distanceModel_val;\n    double theta;\n    //TEST //for (double i = -5.1 ; i< 5.1 ; i++) cout<<\"Theta \"<<i<< \" f: \"<<f(i)<<\" dev: \"<<fdev(i)<<endl;\n    theta= rtsafe(initialGuess, UPPER_THETA, xacc);\n    //cout<<\"newton \"<<j_index_<<\" \"<<dist_avg_<<\" \"<<theta<<endl;\n    return theta;\n}\n\n/*\n * Calculates Newton algorithms f and fdev functions\n */\nvoid Newton_raphson::funcd(double theta, double *ff, double *ffdev) {\n    //*ff = f(theta, n, Vjs);\n    //*ffdev = fdev(theta, n);\n    *ff=f(theta);\n    *ffdev=fdev(theta);\n}\n\n/*\n * Newton - Rapshon execution algorithm.\n */\ndouble Newton_raphson::rtsafe(double x1, double x2, double xacc) {\n    int j;\n    double dx, dxold;\n    double  temp, xh, xl, rts;\n    double f, df, fl, fh;\n    \n    funcd(x1, &fl, &df);//params,: theta, f, fdev\n    funcd(x2, &fh, &df);\n    //if ((fl > 0.0 && fh > 0.0) || (fl < 0.0 && fh < 0.0))\n    //\tcout<<\"Root must be bracketed in rtsafe\"<<endl;\n    if (fl == 0.0)\n        return x1;\n    if (fh == 0.0)\n        return x2;\n    if (fl < 0.0) {\n        xl = x1;\n        xh = x2;\n    }\n    else {\n        xh = x1;\n        xl = x2;\n    }\n    rts = 0.5 * (x1 + x2);\n    rts = x1; //<-fijamos un valor inicial para el theta.\n    dxold = fabs(x2 - x1);\n    dx = dxold;\n    funcd(rts, &f, &df);\n    for (j = 1; j <= MAXIT; j++) {\n        //cout<<\"rts: \"<<rts<<\". Function val: \"<<f<<\" f_dev \"<<df<<endl;\n        //Initialize the guess for root, the “stepsize before last,” and the last step.\n        //Loop over allowed iterations.\n        if ((((rts - xh) * df - f)*((rts - xl) * df - f) > 0.0)   || (fabs(2.0 * f) > fabs(dxold * df))) {\n            //Bisect if Newton out of range, //or not decreasing fast enough.\n            dxold = dx;\n            dx = 0.5 * (xh - xl);\n            rts = xl + dx;\n            if (xl == rts)\n                return rts;\n        }\n        else {\n            dxold = dx;\n            dx = f / df;\n            temp = rts;\n            rts -= dx;\n            if (temp == rts)\n                return rts;\n            //Change in root is negligible. Newton step acceptable. Take it.\n        }\n        //cout<<\"DX: \"<<dx<<endl;\n        if (fabs(dx) < xacc) {\n            return rts;\n        }\n        funcd(rts, &f, &df); //The one new function evaluation per iteration.\n        //Orient the search so that f(xl) < 0.\n        //Convergence criterion.\n        \n        if (f < 0.0) //Maintain the bracket on the root.\n            xl = rts;\n        else\n            xh = rts;\n        \n        //cout<<\"j_index: \"<<j_index_<<\" dist_avg_: \"<<dist_avg_<<\" rts: \"<<rts<<\" Function val: \"<<f<<\" f_dev \"<<df<<endl;\n    }\n  //  cout << \"Maximum number of iterations exceeded in rtsafe\" << endl;\n    \n    return 0.0; //Never get here.\n}\n\n\n// * Theta parameter estimation function.\ndouble Newton_raphson::f(double theta) {\n    if(distance_id_== CAYLEY_DISTANCE){//Cayley distance\n        double sum=0;\n        for(int j = 1 ; j < n_ ; j++){\n            double ex = exp(theta);\n            double denom = j+ex;\n            sum += (double)j/denom;\n            //sum += (double) j /(double)(exp(theta)+(double)j);\n        }\n        return (double)(sum - (double)dist_avg_);\n    }else if (distance_id_ == KENDALL_DISTANCE && model_ == MALLOWS_MODEL){//kendall MM\n        double aux= 0;\n        for(int j = 1 ; j < n_ ; j++){\n            int k = n_ - j + 1;\n            aux += (k * exp(-theta * k))/(1 - exp(-theta * k));\n        }\n        double aux2 = (n_-1) / (exp( theta ) - 1) - dist_avg_;\n        //cout<<\"trace theta :\"<<theta<<\" fval \"<<aux2-aux<<endl;\n        return aux2 - aux;\n    }else if (distance_id_ == KENDALL_DISTANCE && model_ == GENERALIZED_MALLOWS_MODEL){//kendall GMM\n        // oper = oper + oper1 + (pow(n - j + 1, 2) * exp(theta * (n - j + 1))) / (double) pow(exp(theta * (n - j + 1)) - 1, 2);\n        int k = n_ - j_index_ + 1;\n        double a = k /( exp(theta * k ) - 1 );\n        double b = 1 / (exp( theta ) - 1 );\n        //cout<<\"trace theta :\"<<theta<<\" fval \"<<dist_avg_<<\" \"<<a<<\" \"<<b<<endl;\n        return dist_avg_ + a - b;\n    }else if(distance_id_ == ULAM_DISTANCE){\n        double numer = 0, denom = 0;\n        for (int d = 0 ; d < n_ - 1; d++){\n            double aux = count_[d ] * exp(-theta *d ) ;\n            numer += aux * d;\n            denom += aux;\n        }\n        return numer / denom - dist_avg_;\n    }else if (distance_id_ == HAMMING_DISTANCE && model_ == MALLOWS_MODEL ){\n        Generic gen;\n        long double     x_j = 0 , sum_to_n = 0 , sum_to_n_1 = 0 , psi = 0 , psi_der = 0;\n        for ( int j = 0 ; j <= n_ ; j++ ){\n            x_j = (long double) pow(exp(theta)-1, j) / facts_[ j ];\n            if ( j < n_ ) sum_to_n_1 += x_j;\n            sum_to_n += x_j;\n            if(sum_to_n> DBL_MAX ||sum_to_n != sum_to_n )\n                return DBL_MAX;\n        }\n        psi = facts_[ n_ ] * exp(-theta * n_ ) * sum_to_n;\n        psi_der = - n_ * psi + facts_[ n_ ] * exp( theta * ( 1 - n_ )) * sum_to_n_1;\n        double f_fligner = (double)  (psi_der / psi + dist_avg_);\n        //cout<<\"theta \"<<theta<<\" dist \"<<dist_avg_<<\" fu \"<<f_fligner<<endl;\n        if(f_fligner != f_fligner )\n            f_fligner=0;//trace\n        return f_fligner;\n    }else if (distance_id_ == HAMMING_DISTANCE && model_ == GENERALIZED_MALLOWS_MODEL ){\n        //cout<<\"Solve Weigthed Hamming Mallows with the multivariate newthon Raphson, mnewt \"<<endl;\n        //exit(1);\n    }\n    return 0;\n}\n\n// Theta parameter estimation function derivation.\ndouble Newton_raphson::fdev(double theta) {\n    if(distance_id_ == CAYLEY_DISTANCE ){\n        double sum=0;\n        for(int j = 1 ; j < n_ ; j++)\n            sum += (double)( - j * exp( theta ))/pow(exp(theta) + j, 2);\n        return sum;\n    }else if ( distance_id_ == KENDALL_DISTANCE &&  model_ == MALLOWS_MODEL ){//kendall mm\n        double aux= 0;\n        for(int j = 1 ; j < n_ ; j++){\n            int k = n_ - j + 1;\n            aux += (k * k * exp( -theta * k ))/pow((1 - exp(-theta * k)) , 2 );\n        }\n        double aux2 = (- n_ + 1) * exp( theta ) / pow ((exp( theta ) - 1) , 2 );\n        return aux2 + aux;\n    }else if ( distance_id_ == KENDALL_DISTANCE && model_ == GENERALIZED_MALLOWS_MODEL){ //kendall gmm\n        int k = n_ - j_index_ + 1;\n        double a = - k * k * exp(theta * k )  /pow ((exp(theta * k ) - 1), 2);\n        double b = exp(theta) / pow ( (exp( theta ) + 1 ), 2 );\n        return a + b;\n    }else if(distance_id_ ==  ULAM_DISTANCE){\n        long double numer1 = 0, numer2 = 0, numer3 = 0, denom = 0;\n        for (int d = 0 ; d < n_ - 1; d ++){\n            long double aux = count_[d] * exp(-theta *d ) ;\n            numer1 += aux * d * d ;\n            numer2 += aux;\n            numer3 += aux * d;\n            denom += aux;\n        }\n        return (-numer1 * numer2 - numer3*numer3)/(denom*denom);\n    }else if (distance_id_ == HAMMING_DISTANCE && model_ == MALLOWS_MODEL ){\n        Generic gen;\n        long double     x_j = 0 , sum_to_n = 0 , sum_to_n_1 = 0 , sum_to_n_2 = 0 , psi=0, psi_der = 0 , psi_der_2 = 0 ;\n\n        for ( int j = 0 ; j <= n_ ; j++ ){\n            x_j = (long double) pow(exp(theta)-1, j) / facts_[ j ];\n            if ( j < n_ -1 ) sum_to_n_2 += x_j;\n            if ( j < n_ ) sum_to_n_1 += x_j;\n            sum_to_n += x_j;\n            if(sum_to_n_1 > DBL_MAX || sum_to_n_1 != sum_to_n_1)\n                return DBL_MAX-1;\n        }\n        psi = facts_[ n_ ] * exp(-theta * n_ ) * sum_to_n;\n        psi_der = - n_ * psi + facts_[ n_ ] * exp(theta*( 1 - n_ )) * sum_to_n_1;\n        psi_der_2 = -n_ * psi_der + facts_[ n_ ] * exp(theta *(1 - n_ )) * ((1 - n_ ) * sum_to_n_1 + sum_to_n_2 );\n        double res = (double) ( - psi_der_2 * psi_der - psi_der * psi_der )/ (psi*psi);\n        //cout<<\"theta \"<<theta<<\" dist \"<<dist_avg_<<\"ps... \"<<psi<<\" \"<<psi_der<<\" \"<<psi_der_2<<\" fd \"<<res<<endl;\n        if(res > DBL_MAX)\n            return DBL_MAX-1;\n        return res;\n    }else if (distance_id_ == HAMMING_DISTANCE && model_ == GENERALIZED_MALLOWS_MODEL ){\n        //cout<<\"Solve Weigthed Hamming Mallows with Newton_raphson::mle_theta_weighted_mallows_hamming \"<<endl;\n        //exit(1);\n    }\n    return 0;\n}\n\n\nvoid Newton_raphson::mle_theta_weighted_mallows_hamming(int m, double*h_avg , double * theta){\n    //OJO : Given a starting point p[1..n]!!!\n    //minimize a function on multiple variables\n    Generic gen;\n    m_          = m;\n    h_avg_      = h_avg;\n    int         iter  = 0 ;\n    double      fmin  = 0 ;\n    double      * point  = new double[ n_ + 1 ];\n    double      * dpoint = new double[ n_ + 1 ];\n    init_optim_wmh();\n    for (int i = 0 ; i < n_; i++)point[ i + 1 ] = 0.2;\n    for ( int j = 0 ; j < n_ ; j ++){\n       // if (h_avg_[ j ] == 0) h_avg_[ j ] = 0.001;//los ceros dan problemas, txapu\n       // if (h_avg_[ j ] >= 1) h_avg_[ j ] =  0.99;\n    }\n    frprmn(point, n_ , 0.0001, &iter , &fmin , &Newton_raphson::likeli_wmh, &Newton_raphson::dlikeli_wmh);\n    for ( int j = 0 ; j < n_ ; j ++) theta[j] = (double) point [ j + 1 ];\n    delete [] point;\n    delete [] dpoint;\n}\n\ndouble Newton_raphson::likeli_wmh(double x[] ){\n    //x is a vector from 1..n\n    //both  likeli_wmh and dlikeli_wmh return the result *(-1) because frprmn is for minimization and we need maximization\n    Generic gen;\n    long double   like = 0, aux1 = 0 , aux2 = 0, sum_theta = 0;\n    bool penalty = false;\n    double  * do_x = new double[ n_ ];\n    for (int i = 0 ; i < n_; i++) {\n        do_x[i]  = (long double)x[i + 1];\n        sum_theta += x[i + 1];\n        if (do_x [ i ] < 0 || do_x [ i ] > 10  )\n            penalty = true;\n    }\n    gen.elementary_symmetric_polynomial(do_x, n_,t_, aux_esp_, esp_ );\n    for (int i = 0 ; i < n_ ; i++)   aux1 += do_x[ i ] * h_avg_[ i ];\n    for (int k = 0 ; k <= n_ ; k++)  aux2 += facts_[ n_ - k ] * esp_[ k ];\n    aux2 = aux2 * exp( -sum_theta ); //psi\n    like = - m_ * ( aux1 + log( aux2 ));\n    \n    delete [] do_x;\n    if (like != like || penalty ){//|| penalty != 0\n        return DBL_MAX;\n    }\n    return - like ;//* (penalty+1);\n}\n\n\nvoid Newton_raphson::dlikeli_wmh(double x[] , double deriv[] ){\n    //derivada de la verosimilitud\n    //x y deriv [1..n]\n    Generic gen;\n    long double   psi = 0  ;\n    double      * do_x      = new double[ n_ ];////el x es un puto vector de 1..n WTF!!!!!!!!!!\n    long double * psi_der   = new long double [ n_ ];\n    double        sum_theta = 0, aux = 0 ;\n    for (int i = 0 ; i < n_; i++)  {\n        do_x[i]  = ( double)x[i + 1];\n        sum_theta += x[ i+1 ];\n    }\n    gen.elementary_symmetric_polynomial(do_x, n_, t_, aux_esp_,esp_ );\n    gen.split_elementary_symmetric_polynomial (esp_, do_x , n_, esp_no_a_, esp_yes_a_);\n    psi = 0 ;\n    for (int k = 0 ; k <= n_ ; k++)\n        psi += facts_[ n_ - k ] * esp_[ k ];\n    psi = psi * exp( -sum_theta ); //psi\n    for (int i = 0 ; i < n_ ; i++){\n        psi_der[ i ] = 0;\n        aux = 0 ;\n        for (int k = 1 ; k <= n_ ; k++)\n            aux += facts_[ n_ - k ] * esp_no_a_[ k - 1][ i ];\n        aux = aux * exp( -sum_theta + do_x[ i ]); //psi\n        psi_der[ i ] = - psi + aux;\n        //both  likeli_wmh and dlikeli_wmh return the result *(-1) because frprmn is for minimization and we need maximization\n        deriv[ i + 1 ] = ( -1 )  * (psi_der[ i ] / psi  + (long double) h_avg_[ i ]) ;\n    }\n    delete [] do_x;\n//    delete [] removed;\n    delete [] psi_der;\n}\n\n\n#include <math.h>\n#define ITMAX 100\n#define EPS1 1.0e-10\n#define FREEALL free_vector(xi,1,n);free_vector(h,1,n);free_vector(g,1,n);\n\nvoid Newton_raphson::frprmn(double p[], int n, double ftol, int *iter, double *fret, double (Newton_raphson::*func)(double []), void (Newton_raphson::*dfunc)(double [], double []))\n{\n    //Given a starting point p[1..n], Fletcher-Reeves-Polak-Ribiere minimization is performed on a function func, using its gradient as calculated by a routine dfunc. The convergence tolerance on the function value is input as ftol. Returned quantities are p (the location of the minimum), iter (the number of iterations that were performed), and fret (the minimum value of the function). The routine linmin is called to perform line minimizations.\n\tint j,its;\n\tlong double gg,gam,fp,dgg;\n\tdouble *g,*h,*xi;//,*vector();\n\tg=vector(1,n);\n\th=vector(1,n);\n\txi=vector(1,n);\n\tfp=(*this.*func)(p);\n\t(*this.*dfunc)(p,xi);\n\tfor (j=1;j<=n;j++) {\n\t\tg[j] = -xi[j];\n\t\txi[j]=h[j]=g[j];\n\t}\n\tfor (its=1;its<=ITMAX;its++) {\n//cout<<\"p[i]: \";for (j=1;j<=n;j++) cout <<p[j]<<\" \";cout<<\" point from frprmn\"<<endl;\n//cout<<\"h_avg: \";for (j=1;j<=n;j++) cout <<h_avg_[j-1]<<\" \";cout<<\" h from frprmn\"<<endl;\n\t\t*iter=its;\n        dlinmin(p,xi,n,fret,func, dfunc);\n        //for (int i = 0 ; i < n ; i++) if (p[ i +1 ]<0) p[i+1] = 0 ;\n        //linmin(p, xi, n, fret, func);\n        if (2.0*fabs(*fret-fp) <= ftol*(fabs(*fret)+fabs(fp)+EPS1)) {\n\t\t\tFREEALL\n\t\t\treturn;\n\t\t}\n\t\tfp=(*this.*func)(p);\n\t\t(*this.*dfunc)(p,xi);\n        dgg=gg=0.0;\n\t\tfor (j=1;j<=n;j++) {\n\t\t\tgg += g[j]*g[j];\n            //dgg += xi[j]*xi[j];\t//or this or the next(see numerical receipes)\n\t\t\tdgg += (xi[j]+g[j])*xi[j];\n\t\t}\n\t\tif (gg == 0.0) {\n\t\t\tFREEALL\n\t\t\treturn;\n\t\t}\n\t\tgam=dgg/gg;\n        for (j=1;j<=n;j++) {\n\t\t\tg[j] = -xi[j];\n\t\t\txi[j]=h[j]=g[j]+gam*h[j];\n\t\t}\n\t}\n    //char str_msg[100];strcpy(str_msg, \"Too many iterations in FRPRMN\");nrerror(str_msg);\n    //ERROR\n}\n\n#undef ITMAX \n#undef EPS1 \n#undef FREEALL \n\n\ndouble   (Newton_raphson::*nrfunc)(double []);\nvoid    (Newton_raphson::*nrdfun)(double [], double [] );\n\nint ncom=0;\ndouble *pcom=0,*xicom=0;\n//void (*nrdfun)(double [], double [] );\n\n#define TOL 2.0e-4\n\n\nvoid Newton_raphson::dlinmin(double p[], double xi[], int n, double *fret,\n                             double (Newton_raphson::*func) (double []),\n                             void  (Newton_raphson::*dfunc)(double [], double []))\n{\n\tint j;\n\tdouble xx,xmin,fx,fb,fa,bx,ax;\n\tncom=n;\n\tpcom=vector(1,n);\n\txicom=vector(1,n);\n\tnrfunc=func;\n\tnrdfun=dfunc;\n\tfor (j=1;j<=n;j++) {\n\t\tpcom[j] =p[j];\n\t\txicom[j]=xi[j];\n\t}\n\tax=0.0;\n\txx=1.0;\n\tbx=2.0;\n\tmnbrak(&ax,&xx,&bx,&fa,&fx,&fb,&Newton_raphson::f1dim);\n\t*fret=dbrent(ax,xx,bx,&Newton_raphson::f1dim,&Newton_raphson::df1dim,TOL,&xmin);\n\tfor (j=1;j<=n;j++) {\n\t\txi[j] *= xmin;\n\t\tp[j] += xi[j];\n        //if (p[ j ] < 0 ) p[j] = 0 ;//test1\n        //if (p[ j ] > 10 ) p[j] = 10 ;\n\t}\n\tfree_vector(xicom,1,n);\n\tfree_vector(pcom, 1,n);\n}\n\n#undef TOL\n\n////\n#define TOL 2.0e-4\n\n//int ncom=0;\t/* defining declarations */\n//float *pcom=0,*xicom=0,(*nrfunc)();\n\n//void linmin(p,xi,n,fret,func)\n//float p[],xi[],*fret,(*func)();\n//int n;\nvoid    Newton_raphson::linmin  (double p [] ,double xi[],int n,double *fret,double (Newton_raphson::*func) (double []))\n{\n\tint j;\n\tdouble xx,xmin,fx,fb,fa,bx,ax;\n//\tfloat brent(),f1dim(),*vector();\n//\tvoid mnbrak(),free_vector();\n    \n\tncom=n;\n\tpcom=vector(1,n);\n\txicom=vector(1,n);\n\tnrfunc=func;\n\tfor (j=1;j<=n;j++) {\n\t\tpcom[j]=p[j];\n\t\txicom[j]=xi[j];\n\t}\n\tax=0.0;\n\txx=1.0;\n\tbx=2.0;\n\tmnbrak(&ax,&xx,&bx,&fa,&fx,&fb,&Newton_raphson::f1dim);\n\t*fret=brent(ax,xx,bx,&Newton_raphson::f1dim,TOL,&xmin);\n\tfor (j=1;j<=n;j++) {\n\t\txi[j] *= xmin;\n\t\tp[j] += xi[j];\n\t}\n\tfree_vector(xicom,1,n);\n\tfree_vector(pcom,1,n);\n}\n\n#undef TOL\n\n////\n\n#define GOLD 1.618034\n#define GLIMIT 100.0\n#define TINY 1.0e-20\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))\n#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);\n\nvoid Newton_raphson::mnbrak(double *ax, double *bx, double *cx, double *fa, double *fb, double *fc, double (Newton_raphson::*func)(double))\n{\n\tdouble ulim,u,r,q,fu,dum;\n    \n\t*fa=(*this.*func)(*ax);\n\t*fb=(*this.*func)(*bx);\n\t/*if (*fb > *fa && *ax == 0 ) {\n        *ax = *bx = *cx = 0.1 ;\n        return ;\n    }*/\n    if (*fb > *fa) {\n\t\tSHFT(dum,*ax,*bx,dum)\n\t\tSHFT(dum,*fb,*fa,dum)\n\t}\n\t*cx=(*bx)+GOLD*(*bx-*ax);\n\t*fc=(*this.*func)(*cx);\n\twhile (*fb > *fc) {\n\t\tr=(*bx-*ax)*(*fb-*fc);\n\t\tq=(*bx-*cx)*(*fb-*fa);\n\t\tu=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/\n        (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n\t\tulim=(*bx)+GLIMIT*(*cx-*bx);\n\t\tif ((*bx-u)*(u-*cx) > 0.0) {\n\t\t\tfu=(*this.*func)(u);\n\t\t\tif (fu < *fc) {\n\t\t\t\t*ax=(*bx);\n\t\t\t\t*bx=u;\n\t\t\t\t*fa=(*fb);\n\t\t\t\t*fb=fu;\n\t\t\t\treturn;\n\t\t\t} else if (fu > *fb) {\n\t\t\t\t*cx=u;\n\t\t\t\t*fc=fu;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tu=(*cx)+GOLD*(*cx-*bx);\n\t\t\tfu=(*this.*func)(u);\n\t\t} else if ((*cx-u)*(u-ulim) > 0.0) {\n\t\t\tfu=(*this.*func)(u);\n\t\t\tif (fu < *fc) {\n\t\t\t\tSHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx))\n\t\t\t\tSHFT(*fb,*fc,fu,(*this.*func)(u))\n\t\t\t}\n\t\t} else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n\t\t\tu=ulim;\n\t\t\tfu=(*this.*func)(u);\n\t\t} else {\n\t\t\tu=(*cx)+GOLD*(*cx-*bx);\n\t\t\tfu=(*this.*func)(u);\n\t\t}\n\t\tSHFT(*ax,*bx,*cx,u)\n\t\tSHFT(*fa,*fb,*fc,fu)\n\t}\n}\n\n#undef GOLD\n#undef GLIMIT\n#undef TINY\n#undef MAX\n#undef SIGN\n#undef SHFT\n\n\n#include <math.h>\n\n#define ITMAX 100\n#define CGOLD 0.3819660\n#define ZEPS 1.0e-10\n#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))\n#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);\n\ndouble Newton_raphson::brent(double ax,double bx,double cx,double (Newton_raphson::*f)(double),double tol,double *xmin)\n//double ax,bx,cx,tol,*xmin;\n//double (*f)();\t/* ANSI: double (*f)(double); */\n{\n\tint iter;\n\tdouble a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n\tdouble e=0.0;\n\t  \n\ta=((ax < cx) ? ax : cx);\n\tb=((ax > cx) ? ax : cx);\n\tx=w=v=bx;\n\tfw=fv=fx=(*this.*f)(x);\n\tfor (iter=1;iter<=ITMAX;iter++) {\n\t\txm=0.5*(a+b);\n\t\ttol2=2.0*(tol1=tol*fabs(x)+ZEPS);\n\t\tif (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n\t\t\t*xmin=x;\n\t\t\treturn fx;\n\t\t}\n\t\tif (fabs(e) > tol1) {\n\t\t\tr=(x-w)*(fx-fv);\n\t\t\tq=(x-v)*(fx-fw);\n\t\t\tp=(x-v)*q-(x-w)*r;\n\t\t\tq=2.0*(q-r);\n\t\t\tif (q > 0.0) p = -p;\n                q=fabs(q);\n                etemp=e;\n                e=d;\n                if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                    d=CGOLD*(e=(x >= xm ? a-x : b-x));\n                    else {\n                        d=p/q;\n                        u=x+d;\n                        if (u-a < tol2 || b-u < tol2)\n                            d=SIGN(tol1,xm-x);\n                            }\n\t\t} else {\n\t\t\td=CGOLD*(e=(x >= xm ? a-x : b-x));\n\t\t}\n\t\tu=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n\t\tfu=(*this.*f)(u);\n\t\tif (fu <= fx) {\n\t\t\tif (u >= x) a=x; else b=x;\n                SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n                } else {\n                    if (u < x) a=u; else b=u;\n                        if (fu <= fw || w == x) {\n                            v=w;\n                            w=u;\n                            fv=fw;\n                            fw=fu;\n                        } else if (fu <= fv || v == x || v == w) {\n                            v=u;\n                            fv=fu;\n                        }\n                }\n\t}\n    //char str_msg[100];strcpy(str_msg,\"Too many iterations in BRENT\");nrerror(str_msg);\n//ERROR\n\t*xmin=x;\n\treturn fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SIGN\n\n\n\n\n#define ITMAX 100\n#define ZEPS 1.0e-10 \n#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))\n#define MOV3(a,b,c, d,e,f) (a)=(d);(b)=(e);(c)=(f);\n\ndouble Newton_raphson::dbrent(double ax, double bx, double cx, double (Newton_raphson::*f)(double), double (Newton_raphson::*df)(double), double tol, double *xmin)\n{\n\tint iter,ok1,ok2;\n\tdouble a,b,d,d1,d2,du,dv,dw,dx,e=0.0;\n\tdouble fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;\n    \n\ta=(ax < cx ? ax : cx);\n\tb=(ax > cx ? ax : cx);\n\tx=w=v=bx;\n\tfw=fv=fx=(*this.*f)(x);//f1\n\tdw=dv=dx=(*this.*df)(x);//df1\n\n    \n\tfor (iter=1;iter<=ITMAX;iter++) {\n\t\txm=0.5*(a+b);\n\t\ttol1=tol*fabs(x)+ZEPS;\n\t\ttol2=2.0*tol1;\n\t\tif (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n\t\t\t*xmin=x;\n\t\t\treturn fx;\n\t\t}\n       if (fabs(e) > tol1) {\n\t\t\td1=2.0*(b-a);\n\t\t\td2=d1;\n\t\t\tif (dw != dx)  d1=(w-x)*dx/(dx-dw);\n                if (dv != dx)  d2=(v-x)*dx/(dx-dv);\n                    u1=x+d1;\n                    u2=x+d2;\n                    ok1 = (a-u1)*(u1-b) > 0.0 && dx*d1 <= 0.0;\n                    ok2 = (a-u2)*(u2-b) > 0.0 && dx*d2 <= 0.0;\n                    olde=e;\n                    e=d;\n                    if (ok1 || ok2) {\n                        if (ok1 && ok2)\n                            d=(fabs(d1) < fabs(d2) ? d1 : d2);\n                            else if (ok1)\n                                d=d1;\n                                else\n                                    d=d2;\n                                    if (fabs(d) <= fabs(0.5*olde)) {\n                                        u=x+d;\n                                        if (u-a < tol2 || b-u < tol2)\n                                            d=SIGN(tol1,xm-x);\n                                            } else {\n                                                d=0.5*(e=(dx >= 0.0 ? a-x : b-x));\n                                            }\n                    } else {\n                        d=0.5*(e=(dx >= 0.0 ? a-x : b-x));\n                    }\n\t\t} else {\n\t\t\td=0.5*(e=(dx >= 0.0 ? a-x : b-x));\n\t\t}\n      \tif (fabs(d) >= tol1) {\n\t\t\tu=x+d;\n\t\t\tfu=(*this.*f)(u);\n\t\t} else {\n\t\t\tu=x+SIGN(tol1,d);\n\t\t\tfu=(*this.*f)(u);\n\t\t\tif (fu > fx) {\n\t\t\t\t*xmin=x;\n\t\t\t\treturn fx;\n\t\t\t}\n\t\t}\n      \tdu=(*this.*df)(u);\n\t\tif (fu <= fx) {\n\t\t\tif (u >= x) a=x; else b=x;\n                MOV3(v,fv,dv, w,fw,dw)\n                MOV3(w,fw,dw, x,fx,dx)\n                MOV3(x,fx,dx, u,fu,du)\n                } else {\n                    if (u < x) a=u; else b=u;\n                        if (fu <= fw || w == x) {\n                            MOV3(v,fv,dv, w,fw,dw)\n                            MOV3(w,fw,dw, u,fu,du)\n                        } else if (fu < fv || v == x || v == w) {\n                            MOV3(v,fv,dv, u,fu,du)\n                        }\n                }\n\t}\n    //ERROR char str_msg[100];strcpy(str_msg, \"Too many iterations in routine DBRENT\");nrerror(str_msg);\n    return 0;\n}\n\n#undef ITMAX\n#undef ZEPS\n#undef SIGN\n#undef MOV3\n\ndouble Newton_raphson::f1dim(double x)\n{\n\tint j;\n\tdouble f,*xt;//,*vector();\n    \n\txt=vector(1,ncom);\n\tfor (j=1;j<=ncom;j++) xt[j]=pcom[j]+x*xicom[j];\n    f=(*this.*nrfunc)(xt);\n    free_vector(xt,1,ncom);\n    return f;\n}\n\ndouble Newton_raphson::df1dim(double x)\n{\n\tint j;\n\tdouble df1=0.0;\n\tdouble *xt,*df;//,*vector();\n\t//void free_vector();\n    \n\txt=vector(1,ncom);\n\tdf=vector(1,ncom);\n\tfor (j=1;j<=ncom;j++) xt[j]=pcom[j]+x*xicom[j];\n    (*this.*nrdfun)(xt,df);\n\tfor (j=1;j<=ncom;j++) df1 += df[j]*xicom[j];\n    free_vector(df,1,ncom);\n    free_vector(xt,1,ncom);\n\n    return df1;\n}\n\n#define NR_END 1\n#define FREE_ARG char*\nvoid Newton_raphson::nrerror(char error_text[])\n/* Numerical Recipes standard error handler */\n{\n\t//fprintf(stderr,\"Numerical Recipes run-time error...\\n\");\n\t//fprintf(stderr,\"%s\\n\",error_text);\n\t//fprintf(stderr,\"...now exiting to system...\\n\");\n\t//exit(1);\n}\n\ndouble *Newton_raphson::vector(long nl, long nh)\n/* allocate a double vector with subscript range v[nl..nh] */\n{\n\tdouble *v;\n    \n\tv=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));\n\tif (!v) {\n        //ERRORchar str_msg[100];strcpy(str_msg, \"allocation failure in vector()\");nrerror(str_msg);\n    }\n\treturn v-nl+NR_END;\n}\n\nvoid Newton_raphson::free_vector(double *v, long nl, long nh)\n/* free a double vector allocated with vector() */\n{\n\tfree((FREE_ARG) (v+nl-NR_END));\n}\n",
    "created" : 1447237474514.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3914894707",
    "id" : "5901D09",
    "lastKnownWriteTime" : 1422024015,
    "path" : "~/Dropbox/permus/prj/R/PerMallows/src/Newton_raphson.cpp",
    "project_path" : "src/Newton_raphson.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}